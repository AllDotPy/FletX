{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-fletx","title":"Welcome to FletX","text":"<p>FletX is a lightweight, modular, and reactive architectural layer built on top of Flet. It helps you structure Python UI apps using clear separation of concerns (Pages \u2192 Controllers \u2192 Services), predictable lifecycle hooks, and a small set of reactive primitives.</p> <p>Quick orientation</p> <ul> <li>Use <code>Pages</code> to describe UI and navigation.</li> <li>Use <code>Controllers</code> for state and business logic.</li> <li>Use <code>Services</code> for reusable integrations (APIs, storage).</li> <li>Use the CLI to scaffold and run projects quickly.</li> </ul>"},{"location":"#what-is-fletx-short","title":"What is FletX? (short)","text":"<p>FletX brings architecture patterns familiar from mobile/web frameworks (for example, GetX) to Flet applications: reactive state management, modular routing, dependency injection, and lifecycle hooks \u2014 without replacing Flet widgets.</p> <p>Key features:</p> <ul> <li>Reactive state primitives (<code>Rx*</code>, <code>Computed</code>, <code>Observer</code>) for straightforward UI updates.</li> <li>A routing system with guards and nested routes.</li> <li>Controllers and Services to separate UI from logic.</li> <li>A small set of decorators and helpers for effects, memoization, and batched updates.</li> <li>A CLI for scaffolding, generation, running, and testing.</li> </ul>"},{"location":"#tldr-get-started-in-three-commands","title":"TL;DR \u2014 Get started in three commands","text":"Bash<pre><code>fletx new my_app             # scaffold a project\ncd my_app\nfletx run --web --watch      # run with hot reload\n</code></pre>"},{"location":"#simple-example-counter","title":"Simple Example (counter)","text":"<p>This minimal example shows how a <code>Page</code> and a <code>Controller</code> work together:</p> Python<pre><code>import flet as ft\nfrom fletx.app import FletXApp\nfrom fletx.core import FletXPage, FletXController, RxInt\nfrom fletx.decorators import obx\n\n\nclass CounterController(FletXController):\n    def __init__(self):\n        self.count = RxInt(0)\n\n    def increment(self):\n        self.count.increment()\n\n\nclass CounterPage(FletXPage):\n    ctrl = CounterController()\n\n    @obx\n    def counter_label(self):\n        return ft.Text(f\"Count: {self.ctrl.count}\")\n\n    def build(self):\n        return ft.Column(controls=[\n            self.counter_label(),\n            ft.ElevatedButton(\"+\", on_click=lambda e: self.ctrl.increment())\n        ])\n\n\ndef main():\n    app = FletXApp(title=\"Counter\", initial_route=\"/\", debug=True)\n    app.run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#learn-path-start-here","title":"Learn Path \u2014 Start here","text":"<ul> <li>Installation: getting-started/installation.md \u2014 Set up your environment and the CLI.</li> <li>Routing: getting-started/routing.md \u2014 Learn navigation, guards, and route parameters.</li> <li>State: getting-started/state-management.md \u2014 Reactive primitives and patterns.</li> <li>Controllers: getting-started/controllers.md \u2014 Where business logic lives.</li> <li>Pages: getting-started/pages.md \u2014 Page lifecycle and composition.</li> <li>Services: getting-started/services.md \u2014 External integrations and utilities.</li> <li>Decorators: getting-started/decorators.md \u2014 Effects, memoization, and more.</li> </ul>"},{"location":"#tools-resources","title":"Tools &amp; Resources","text":"<ul> <li>CLI: <code>fletx</code> \u2014 scaffold, generate, run, and test projects. See getting-started/fletx-cli.md for usage.</li> <li>API Reference: api-reference.md \u2014 exhaustive list of classes and helpers.</li> <li>Examples: examples/template \u2014 a starter project you can run and adapt.</li> </ul>"},{"location":"#community-contributing","title":"Community &amp; Contributing","text":"<ul> <li>GitHub: https://github.com/AllDotPy/FletX</li> <li>Discord: https://discord.gg/GRez7BTZVy</li> <li>To contribute: read CONTRIBUTING.md and open a PR.</li> </ul> <p>Made with \u2764\ufe0f by AllDotPy</p>"},{"location":"CODE_OF_CONDUCT/","title":"\ud83d\udd4a FletX Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"\ud83c\udf1f Our Pledge","text":"<p>We pledge to foster an open, inclusive, and respectful environment for all contributors, regardless of: </p> <ul> <li>Background or experience level  </li> <li>Gender identity or expression  </li> <li>Sexual orientation  </li> <li>Disability  </li> <li>Personal appearance  </li> <li>Race, ethnicity, or religion  </li> <li>Technology preferences  </li> </ul>"},{"location":"CODE_OF_CONDUCT/#unacceptable-behavior","title":"\ud83d\udeab Unacceptable Behavior","text":"<p>Examples include but are not limited to:</p> <ul> <li>Harassment or derogatory comments  </li> <li>Trolling or personal/political attacks  </li> <li>Publishing others' private information without consent  </li> <li>Other conduct that could reasonably be considered inappropriate  </li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"\ud83d\udee0 Enforcement Responsibilities","text":"<p>Project maintainers will:</p> <ul> <li>Remove/edit inappropriate content  </li> <li>Warn or ban offenders temporarily/permanently  </li> <li>Apply consequences fairly and consistently  </li> </ul>"},{"location":"CODE_OF_CONDUCT/#reporting-guidelines","title":"\u2696\ufe0f Reporting Guidelines","text":"<p>Report violations to [project email/contact] with:</p> <ol> <li>Where/when the incident occurred  </li> <li>Description of the behavior  </li> <li>Context (if available)  </li> <li>Your contact information (optional)  </li> </ol> <p>All reports will be reviewed and investigated promptly.  </p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"\ud83d\udd04 Attribution","text":"<p>This Code of Conduct is adapted from:</p> <ul> <li>Contributor Covenant 2.1 </li> <li>Django Code of Conduct </li> </ul>"},{"location":"contributing/","title":"Contributing to FletX","text":"<p>Thank you for your interest in FletX! \ud83c\udf89 This comprehensive guide outlines how to contribute effectively.</p>"},{"location":"contributing/#table-of-contents","title":"\ud83d\udccb Table of Contents","text":"<ol> <li>Getting Started</li> <li>Project Structure</li> <li>Development Workflow</li> <li>Code Conventions</li> <li>Testing &amp; Quality</li> <li>Documentation</li> <li>Reporting Bugs</li> <li>Feature Proposals</li> <li>Code of Conduct</li> </ol>"},{"location":"contributing/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"contributing/#local-setup","title":"Local Setup","text":"<ol> <li> <p>Clone the repository Bash<pre><code>git clone https://github.com/AllDotPy/FletX.git\ncd FletX\n</code></pre></p> </li> <li> <p>Set up virtual environment (Recommended: UV) Bash<pre><code>pip install uv\nuv venv\nsource venv/bin/activate  # Linux/Mac\n# or .\\venv\\Scripts\\activate  # Windows\n</code></pre></p> </li> <li> <p>Install dependencies Bash<pre><code>uv pip install -e .[dev]  # Development mode\n</code></pre></p> </li> <li> <p>Verify installation Bash<pre><code>pytest tests/\n</code></pre></p> </li> </ol>"},{"location":"contributing/#project-structure","title":"\ud83c\udfd7 Project Structure","text":"Bash<pre><code>.\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 architecture.svg\n\u251c\u2500\u2500 docs/\n\u251c\u2500\u2500 examples/\n\u251c\u2500\u2500 fletx\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 core\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 controller.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 di.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 effects.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 factory.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 navigation\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 guards.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 middleware.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 transitions.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 observer.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 page.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 route_config.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 router.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 state.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 types.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 widget.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 decorators\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 controllers.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 reactive.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 route.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 utils\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 context.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 exceptions.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 logger.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 widgets\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 text.py\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 setup.py\n</code></pre>"},{"location":"contributing/#development-workflow","title":"\ud83d\udd04 Development Workflow","text":"<ol> <li> <p>Create a branch    Branch from <code>master</code> with descriptive naming:    Bash<pre><code>git checkout -b feat/new-reactive-component\n</code></pre></p> </li> <li> <p>Implement changes </p> </li> <li>Keep commits atomic</li> <li> <p>Document new features</p> </li> <li> <p>Run tests Bash<pre><code>uv pip install -e .[test]\npytest tests/\n</code></pre></p> </li> <li> <p>Submit a Pull Request</p> </li> <li>Clearly describe changes</li> <li>Reference related issues</li> <li>Address code review feedback</li> </ol>"},{"location":"contributing/#code-conventions","title":"\u2728 Code Conventions","text":""},{"location":"contributing/#style-guide","title":"Style Guide","text":"<ul> <li>Follow PEP 8 (88 chars max line length)</li> <li>Type hints for all public functions</li> <li>Google-style docstrings for key modules</li> </ul>"},{"location":"contributing/#reactivity-pattern","title":"Reactivity Pattern","text":"Python<pre><code># Good\nclass ReactiveButton(ft.ElevatedButton, FletXWidget):\n    \"\"\" My Reactive Button which.... \"\"\"\n\n    def __init__(self, text: RxStr, **kwargs):\n        super().__init__(**kwargs)\n        # Create a reactive object\n        self.rx_text: RxStr = RxStr('')\n        # And bind it to self (@ft.ElevatedButton) text attribute\n        self.bind('text', self.rx_text)\n</code></pre>"},{"location":"contributing/#widget-standards","title":"Widget Standards","text":"<ul> <li>Prefix reactive widgets with <code>Reactive</code></li> <li>Isolate state logic in dedicated classes</li> </ul>"},{"location":"contributing/#testing-quality","title":"\ud83e\uddea Testing &amp; Quality","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"Bash<pre><code>pytest tests/ --cov=fletx --cov-report=html\n</code></pre>"},{"location":"contributing/#quality-standards","title":"Quality Standards","text":"<ul> <li>Maintain &gt;90% code coverage</li> <li>All new widgets require:</li> <li>Unit tests</li> <li>Functional example</li> <li>Documentation</li> </ul>"},{"location":"contributing/#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"contributing/#writing-docs","title":"Writing Docs","text":"Python<pre><code>class ReactiveText(ft.Text, FletXWidget):\n    \"\"\"Text widget with reactive value binding.\n\n    Args:\n        value: RxStr to bind to text value\n        color: RxStr for text color (optional)\n    \"\"\"\n</code></pre>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"Bash<pre><code>cd docs/\nmake html\n</code></pre>"},{"location":"contributing/#reporting-bugs","title":"\ud83d\udc1b Reporting Bugs","text":"<ol> <li>Check existing issues for duplicates</li> <li>Include:</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>FletX/Python versions</li> <li>Minimal reproducible example</li> </ol>"},{"location":"contributing/#feature-proposals","title":"\ud83d\udca1 Feature Proposals","text":"<ol> <li>Clearly describe the use case</li> <li>Suggest technical approach</li> <li>Outline potential impacts</li> <li>Attach mockups if applicable</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"\ud83e\udd1d Code of Conduct","text":"<p>We adhere to the Contributor Covenant Code of Conduct. By participating: - Be kind and open-minded - Respect differing viewpoints - Assume good faith</p> <p>Thank you for helping build FletX! Together we're creating the best reactive framework for Flet. \ud83d\ude80</p>"},{"location":"drafts/fletxapp/","title":"FletXApp Draft","text":""},{"location":"drafts/fletxapp/#documentation","title":"\ud83c\uddeb\ud83c\uddf7 Documentation","text":""},{"location":"drafts/fletxapp/#fletxapp","title":"<code>FletXApp</code>","text":""},{"location":"drafts/fletxapp/#description","title":"Description","text":"<p>La classe <code>FletXApp</code> est le point d\u2019entr\u00e9e principal d\u2019une application FletX, offrant une configuration fluide, un support pour les modes synchrone et asynchrone, et des hooks pour le cycle de vie (<code>on_startup</code>, <code>on_shutdown</code>).</p>"},{"location":"drafts/fletxapp/#parametres-du-constructeur","title":"Param\u00e8tres du constructeur","text":"Param\u00e8tre Type Description <code>initial_route</code> <code>str</code> Route initiale (ex: <code>/</code>) <code>theme_mode</code> <code>ft.ThemeMode</code> Mode du th\u00e8me (<code>SYSTEM</code>, <code>LIGHT</code>, <code>DARK</code>) <code>debug</code> <code>bool</code> Active le mode debug <code>title</code> <code>str</code> Titre de l\u2019application <code>theme</code> <code>Optional[ft.Theme]</code> Th\u00e8me clair <code>dark_theme</code> <code>Optional[ft.Theme]</code> Th\u00e8me sombre <code>window_config</code> <code>Optional[Dict]</code> Configuration de la fen\u00eatre (largeur, hauteur\u2026) <code>middlewares</code> <code>...</code> (D\u00e9pr\u00e9ci\u00e9) <code>on_startup</code> <code>Union[Callable, List[Callable]]</code> Hooks au d\u00e9marrage <code>on_shutdown</code> <code>Union[Callable, List[Callable]]</code> Hooks \u00e0 l\u2019arr\u00eat <code>**kwargs</code> <code>dict</code> Arguments suppl\u00e9mentaires pour <code>ft.app()</code>"},{"location":"drafts/fletxapp/#methodes-cles","title":"M\u00e9thodes cl\u00e9s","text":"<ul> <li><code>with_title(title: str)</code>: d\u00e9finit le titre (fluent).</li> <li><code>with_theme(theme: ft.Theme)</code>: th\u00e8me clair (fluent).</li> <li><code>with_dark_theme(dark_theme: ft.Theme)</code>: th\u00e8me sombre (fluent).</li> <li><code>with_window_size(width: int, height: int)</code>: configure la fen\u00eatre (fluent).</li> <li><code>with_debug(debug: bool)</code>: active/d\u00e9sactive le debug (fluent).</li> <li><code>add_startup_hook(hook: Callable)</code>: ajoute un hook au d\u00e9marrage.</li> <li><code>add_shutdown_hook(hook: Callable)</code>: ajoute un hook \u00e0 la fermeture.</li> <li><code>run(**kwargs)</code>, <code>run_async(**kwargs)</code>: ex\u00e9cution sync/async.</li> <li><code>run_web(host, port, **kwargs)</code>, <code>run_desktop(**kwargs)</code>: modes web ou bureau.</li> <li><code>is_initialized</code>, <code>page</code>: propri\u00e9t\u00e9s d\u2019\u00e9tat.</li> <li><code>get_context_data(key, default)</code>, <code>set_context_data(key, value)</code>: acc\u00e8s au <code>AppContext</code>.</li> </ul>"},{"location":"drafts/fletxapp/#cycle-de-vie","title":"Cycle de vie","text":"<ol> <li>Configuration de la fen\u00eatre et du th\u00e8me.</li> <li>Ex\u00e9cution des hooks <code>on_startup</code>.</li> <li>Initialisation du <code>AppContext</code> et du <code>FletXRouter</code>.</li> <li>Passage en mode <code>is_initialized = True</code>.</li> <li>\u00c0 la fermeture, ex\u00e9cution des hooks <code>on_shutdown</code>.</li> </ol>"},{"location":"drafts/fletxapp/#exemples-dutilisation","title":"Exemples d\u2019utilisation","text":"Python<pre><code>from fletx.app import FletXApp\nimport flet as ft\n\n# Ex\u00e9cution simple (mode sync)\napp = (FletXApp(title=\"Ma Super App\", initial_route=\"/home\", debug=True)\n       .with_window_size(450, 700)\n       .with_theme(ft.Theme(color_scheme_seed=ft.Colors.BLUE)))\napp.run()\n</code></pre> Python<pre><code># Mode web asynchrone avec hooks\nasync def on_start(page: ft.Page):\n    print(\"D\u00e9marrage\")\n\ndef on_stop(page: ft.Page):\n    print(\"Arr\u00eat\")\n\napp = FletXApp(\n    title=\"App Web\",\n    debug=False,\n    on_startup=on_start,\n    on_shutdown=on_stop\n)\napp.run_web(host=\"0.0.0.0\", port=8080)\n</code></pre>"},{"location":"drafts/fletxapp/#documentation_1","title":"\ud83c\uddec\ud83c\udde7 Documentation","text":""},{"location":"drafts/fletxapp/#fletxapp_1","title":"<code>FletXApp</code>","text":""},{"location":"drafts/fletxapp/#description_1","title":"Description","text":"<p><code>FletXApp</code> is the main entry point for a FletX application. It provides fluent configuration, supports both synchronous and asynchronous execution modes, and lifecycle hooks (<code>on_startup</code>, <code>on_shutdown</code>).</p>"},{"location":"drafts/fletxapp/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Description <code>initial_route</code> <code>str</code> Initial route (e.g. <code>/</code>) <code>theme_mode</code> <code>ft.ThemeMode</code> Theme mode (<code>SYSTEM</code>, <code>LIGHT</code>, <code>DARK</code>) <code>debug</code> <code>bool</code> Enable debug mode <code>title</code> <code>str</code> App title <code>theme</code> <code>Optional[ft.Theme]</code> Light theme <code>dark_theme</code> <code>Optional[ft.Theme]</code> Dark theme <code>window_config</code> <code>Optional[Dict]</code> Window config (width, height\u2026) <code>middlewares</code> <code>...</code> (Deprecated) <code>on_startup</code> <code>Union[Callable, List[Callable]]</code> Startup hooks <code>on_shutdown</code> <code>Union[Callable, List[Callable]]</code> Shutdown hooks <code>**kwargs</code> <code>dict</code> Additional <code>ft.app()</code> params"},{"location":"drafts/fletxapp/#key-methods","title":"Key Methods","text":"<ul> <li><code>with_title(title)</code>: set title (fluent).</li> <li><code>with_theme(theme)</code>: set light theme (fluent).</li> <li><code>with_dark_theme(dark_theme)</code>: set dark theme (fluent).</li> <li><code>with_window_size(w,h)</code>: configure window (fluent).</li> <li><code>with_debug(debug)</code>: toggle debug mode (fluent).</li> <li><code>add_startup_hook(hook)</code>, <code>add_shutdown_hook(hook)</code> to add lifecycle hooks.</li> <li><code>run()</code>, <code>run_async()</code>: synchronous/asynchronous execution.</li> <li><code>run_web(host,port)</code>, <code>run_desktop()</code>: run in web or desktop mode.</li> <li><code>is_initialized</code>, <code>page</code>: status properties.</li> <li><code>get_context_data(key, default)</code>, <code>set_context_data(key, value)</code>: get/set context data.</li> </ul>"},{"location":"drafts/fletxapp/#lifecycle-overview","title":"Lifecycle Overview","text":"<ol> <li>Setup window and theme.</li> <li>Execute <code>on_startup</code> hooks.</li> <li>Initialize <code>AppContext</code> and <code>FletXRouter</code>.</li> <li>Set <code>is_initialized</code> to <code>True</code>.</li> <li>On exit, execute <code>on_shutdown</code> hooks.</li> </ol>"},{"location":"drafts/fletxapp/#usage-examples","title":"Usage Examples","text":"Python<pre><code>from fletx.app import FletXApp\nimport flet as ft\n\n# Simple sync run\napp = (FletXApp(title=\"My App\", initial_route=\"/home\", debug=True)\n       .with_window_size(450, 700)\n       .with_theme(ft.Theme(color_scheme_seed=ft.Colors.BLUE)))\napp.run()\n</code></pre> Python<pre><code># Async web run with hooks\nasync def on_start(page: ft.Page):\n    print(\"App started\")\n\ndef on_stop(page: ft.Page):\n    print(\"App stopped\")\n\napp = FletXApp(\n    title=\"Web App\",\n    debug=False,\n    on_startup=on_start,\n    on_shutdown=on_stop\n)\napp.run_web(host=\"0.0.0.0\", port=8080)\n</code></pre>"},{"location":"drafts/fletxapp/#tests-avec-pytest","title":"\ud83c\uddeb\ud83c\uddf7 Tests avec <code>pytest</code>","text":"Python<pre><code># test_fletx_app.py\n\nimport pytest\nimport flet\nfrom fletx.app import FletXApp\nfrom fletx.utils.context import AppContext\n\n@pytest.fixture(autouse=True)\ndef reset_context():\n    AppContext._data.clear()\n    yield\n    AppContext._data.clear()\n\ndef test_sync_run_initializes(tmp_path, monkeypatch):\n    calls = []\n\n    def fake_app(target, **kwargs):\n        class DummyPage:\n            title = \"\"\n            theme = None\n            dark_theme = None\n            window = type(\"W\", (), {})()\n            def update(self): pass\n        page = DummyPage()\n        target(page)\n        calls.append(page)\n\n    monkeypatch.setattr(flet, \"app\", fake_app)\n\n    app = FletXApp(title=\"Test\", debug=True, initial_route=\"/foo\")\n    app.run()\n\n    assert app.is_initialized\n    assert isinstance(app.page, object)\n    assert AppContext.get_data(\"app\") == app\n\ndef test_on_startup_and_shutdown_hooks(monkeypatch):\n    calls = []\n    async def async_hook(page): calls.append(\"start-async\")\n    def sync_hook(page): calls.append(\"start-sync\")\n    def shutdown_hook(page): calls.append(\"stop-sync\")\n\n    def fake_app(target, **kwargs):\n        class Dummy:\n            title = \"\"\n            theme = None\n            dark_theme = None\n            window = type(\"W\", (), {})()\n            def update(self): pass\n        page = Dummy()\n        target(page)\n        return\n\n    monkeypatch.setattr(flet, \"app\", fake_app)\n\n    app = FletXApp(on_startup=[async_hook, sync_hook], on_shutdown=shutdown_hook)\n    app.run()\n\n    assert \"start-async\" in calls\n    assert \"start-sync\" in calls\n    assert \"stop-sync\" in calls\n\ndef test_context_data_set_get():\n    app = FletXApp()\n    app.set_context_data(\"foo\", 42)\n    assert app.get_context_data(\"foo\") == 42\n    assert app.get_context_data(\"bar\", \"baz\") == \"baz\"\n</code></pre>"},{"location":"drafts/fletxapp/#tests-with-pytest","title":"\ud83c\uddec\ud83c\udde7 Tests with <code>pytest</code>","text":"Python<pre><code># test_fletx_app.py\n\nimport pytest\nimport flet\nfrom fletx.app import FletXApp\nfrom fletx.utils.context import AppContext\n\n@pytest.fixture(autouse=True)\ndef reset_context():\n    AppContext._data.clear()\n    yield\n    AppContext._data.clear()\n\ndef test_sync_run_initializes(tmp_path, monkeypatch):\n    calls = []\n\n    def fake_app(target, **kwargs):\n        class DummyPage:\n            title = \"\"\n            theme = None\n            dark_theme = None\n            window = type(\"W\", (), {})()\n            def update(self): pass\n        page = DummyPage()\n        target(page)\n        calls.append(page)\n\n    monkeypatch.setattr(flet, \"app\", fake_app)\n\n    app = FletXApp(title=\"Test\", debug=True, initial_route=\"/foo\")\n    app.run()\n\n    assert app.is_initialized\n    assert isinstance(app.page, object)\n    assert AppContext.get_data(\"app\") == app\n\ndef test_on_startup_and_shutdown_hooks(monkeypatch):\n    calls = []\n    async def async_hook(page): calls.append(\"start-async\")\n    def sync_hook(page): calls.append(\"start-sync\")\n    def shutdown_hook(page): calls.append(\"stop-sync\")\n\n    def fake_app(target, **kwargs):\n        class Dummy:\n            title = \"\"\n            theme = None\n            dark_theme = None\n            window = type(\"W\", (), {})()\n            def update(self): pass\n        page = Dummy()\n        target(page)\n        return\n\n    monkeypatch.setattr(flet, \"app\", fake_app)\n\n    app = FletXApp(on_startup=[async_hook, sync_hook], on_shutdown=shutdown_hook)\n    app.run()\n\n    assert \"start-async\" in calls\n    assert \"start-sync\" in calls\n    assert \"stop-sync\" in calls\n\ndef test_context_data_set_get():\n    app = FletXApp()\n    app.set_context_data(\"foo\", 42)\n    assert app.get_context_data(\"foo\") == 42\n    assert app.get_context_data(\"bar\", \"baz\") == \"baz\"\n</code></pre> <p>\ud83d\udca1 \u00c0 noter : les tests simulent <code>flet.app()</code> pour forcer l\u2019ex\u00e9cution de <code>target(page)</code>. Les hooks asynchrones sont correctement pris en charge. Si tu veux aller plus loin, je peux ajouter des tests pour <code>run_async</code>, <code>run_web</code>, <code>run_desktop</code>, etc. veux-tu que je m\u2019en occupe ?</p> Python<pre><code>\"\"\"\nExemples d'utilisation de la nouvelle FletXApp\n\"\"\"\n\nimport flet as ft\nfrom fletx.app import FletXApp\n\n# ==============================\n# EXEMPLE 1: Configuration Simple\n# ==============================\n\ndef example_simple():\n    \"\"\"Exemple basique avec configuration simple\"\"\"\n\n    app = FletXApp(\n        title=\"Mon App FletX\",\n        initial_route=\"/\",\n        debug=True\n    ).with_window_size(400, 600).with_theme(\n        ft.Theme(color_scheme_seed=ft.Colors.BLUE)\n    )\n\n    # Run sync\n    app.run()\n\n# ==============================\n# EXEMPLE 2: Configuration Avanc\u00e9e\n# ==============================\n\ndef example_advanced():\n    \"\"\"Exemple avec configuration avanc\u00e9e\"\"\"\n\n    # Hooks de d\u00e9marrage et arr\u00eat\n    async def on_startup(page: ft.Page):\n        print(\"App d\u00e9marr\u00e9e!\")\n        # Initialiser des services, base de donn\u00e9es, etc.\n\n    def on_shutdown(page: ft.Page):\n        print(\"App ferm\u00e9e!\")\n        # Nettoyer les ressources\n\n    # Middleware\n    def auth_middleware(page: ft.Page):\n        print(\"V\u00e9rification d'authentification...\")\n\n    app = FletXApp(\n        title=\"App Avanc\u00e9e\",\n        initial_route=\"/dashboard\",\n        debug=True,\n        theme=ft.Theme(color_scheme_seed=ft.Colors.GREEN),\n        dark_theme=ft.Theme(\n            color_scheme_seed=ft.Colors.BLUE_800,\n            scaffold_bgcolor=ft.Colors.BLACK\n        ),\n        window_config={\n            \"width\": 800,\n            \"height\": 600,\n            \"resizable\": True,\n            \"maximizable\": True\n        },\n        middlewares=[auth_middleware],\n        on_startup=on_startup,\n        on_shutdown=on_shutdown\n    )\n\n    # Run async\n    app.run_async()\n\n# ==============================\n# EXEMPLE 3: Style Fluent Interface\n# ==============================\n\ndef example_fluent():\n    \"\"\"Exemple avec interface fluide\"\"\"\n\n    def logging_middleware(page: ft.Page):\n        print(f\"Page: {page.title} - Route: {page.route}\")\n\n    async def setup_database(page: ft.Page):\n        print(\"Configuration de la base de donn\u00e9es...\")\n        # Simulation d'une t\u00e2che async\n        import asyncio\n        await asyncio.sleep(0.1)\n\n    app = (FletXApp()\n           .with_title(\"Interface Fluide\")\n           .with_window_size(1000, 700)\n           .with_theme(ft.Theme(color_scheme_seed=ft.Colors.PURPLE))\n           .with_debug(True)\n           .add_middleware(logging_middleware)\n           .add_startup_hook(setup_database))\n\n    app.run_web(port=8080)\n\n# ==============================\n# EXEMPLE 4: Mode Web avec Hooks Multiples\n# ==============================\n\ndef example_web_app():\n    \"\"\"Exemple d'application web avec hooks multiples\"\"\"\n\n    async def init_services(page: ft.Page):\n        print(\"Initialisation des services...\")\n\n    async def load_config(page: ft.Page):\n        print(\"Chargement de la configuration...\")\n\n    def cleanup_temp_files(page: ft.Page):\n        print(\"Nettoyage des fichiers temporaires...\")\n\n    app = FletXApp(\n        title=\"Web App FletX\",\n        theme_mode=ft.ThemeMode.LIGHT,\n        on_startup=[init_services, load_config],\n        on_shutdown=cleanup_temp_files\n    )\n\n    app.run_web(host=\"0.0.0.0\", port=3000)\n\n# ==============================\n# EXEMPLE 5: Usage avec ft.app (style classique am\u00e9lior\u00e9)\n# ==============================\n\ndef example_classic_style():\n    \"\"\"Exemple avec style classique mais am\u00e9lior\u00e9\"\"\"\n\n    app = FletXApp(\n        title=\"Style Classique\",\n        initial_route=\"/home\",\n        debug=True,\n        window_config={\"width\": 500, \"height\": 400}\n    )\n\n    def main(page: ft.Page):\n        # Configuration personnalis\u00e9e de la page si n\u00e9cessaire\n        page.bgcolor = ft.Colors.BLUE_50\n\n        # Utiliser le handler de l'app\n        app._sync_main(page)\n\n    ft.app(target=main)\n\n# ==============================\n# EXEMPLE 6: Application Async Compl\u00e8te\n# ==============================\n\ndef example_async_complete():\n    \"\"\"Exemple d'application compl\u00e8tement asynchrone\"\"\"\n\n    async def async_main():\n        app = FletXApp(title=\"App Async\")\n\n        async def main_handler(page: ft.Page):\n            await app._async_main(page)\n\n            # Logique async personnalis\u00e9e apr\u00e8s initialisation\n            print(\"Application initialis\u00e9e, d\u00e9marrage des t\u00e2ches de fond...\")\n\n        # Utiliser le handler async\n        ft.app(target=lambda page: asyncio.run(main_handler(page)))\n\n    import asyncio\n    asyncio.run(async_main())\n\n# ==============================\n# EXEMPLE 7: Configuration Dynamique\n# ==============================\n\ndef example_dynamic_config():\n    \"\"\"Exemple avec configuration dynamique\"\"\"\n\n    # Configuration bas\u00e9e sur l'environnement\n    import os\n    is_production = os.getenv(\"ENV\") == \"production\"\n\n    app = FletXApp(\n        debug=not is_production,\n        theme_mode=ft.ThemeMode.DARK if is_production else ft.ThemeMode.LIGHT,\n        window_config={\n            \"width\": 1200 if is_production else 800,\n            \"height\": 800 if is_production else 600\n        }\n    )\n\n    # Configuration conditionnelle\n    if not is_production:\n        app.add_middleware(lambda page: print(f\"DEBUG: Route = {page.route}\"))\n\n    app.run_desktop()\n\nif __name__ == \"__main__\":\n    # Lancer un des exemples\n    example_fluent()\n</code></pre>"},{"location":"drafts/fletxcli/","title":"Fletxcli","text":""},{"location":"drafts/fletxcli/#fletx-cli-documentation","title":"\ud83c\uddeb\ud83c\uddf7 FletX CLI - Documentation","text":""},{"location":"drafts/fletxcli/#introduction","title":"Introduction","text":"<p>Le CLI de FletX (<code>fletx</code>) est un outil en ligne de commande qui facilite la gestion des projets FletX. Il vous permet de :</p> <ul> <li>Cr\u00e9er un nouveau projet FletX</li> <li>G\u00e9n\u00e9rer des composants (contr\u00f4leurs, services, pages, etc.)</li> <li>Ex\u00e9cuter votre projet avec diff\u00e9rentes options</li> </ul>"},{"location":"drafts/fletxcli/#commande-principale","title":"Commande principale","text":"Bash<pre><code>fletx &lt;commande&gt; [options]\n</code></pre>"},{"location":"drafts/fletxcli/#commandes-disponibles","title":"Commandes disponibles","text":"Cat\u00e9gorie Commande Description Gestion de projet <code>new</code> Cr\u00e9e un nouveau projet FletX \u00e0 partir d'un mod\u00e8le G\u00e9n\u00e9ration de code <code>generate</code> G\u00e9n\u00e8re des composants comme des contr\u00f4leurs, services... Utilitaires <code>run</code> Ex\u00e9cute un projet FletX avec diverses options <p>\ud83d\udc49 Aide sp\u00e9cifique :</p> Bash<pre><code>fletx &lt;commande&gt; --help\nfletx help &lt;commande&gt;\n</code></pre>"},{"location":"drafts/fletxcli/#fletx-new","title":"<code>fletx new</code>","text":"<p>Cr\u00e9er un nouveau projet FletX.</p> Bash<pre><code>fletx new &lt;nom_du_projet&gt; [options]\n</code></pre>"},{"location":"drafts/fletxcli/#options","title":"Options","text":"Option Description Par d\u00e9faut <code>--template TEMPLATE</code> Mod\u00e8le \u00e0 utiliser pour le projet <code>project</code> <code>--directory DIRECTORY</code> Dossier o\u00f9 cr\u00e9er le projet dossier courant <code>--author AUTHOR</code> Nom de l'auteur <code>--description DESCRIPTION</code> Description du projet <code>--version VERSION</code> Version initiale du projet <code>0.1.0</code> <code>--python-version PYTHON_VERSION</code> Version minimale de Python requise <code>3.12</code> <code>--overwrite</code> \u00c9crase les fichiers existants si pr\u00e9sents <code>--no-install</code> Ne pas installer les d\u00e9pendances apr\u00e8s cr\u00e9ation"},{"location":"drafts/fletxcli/#fletx-generate","title":"<code>fletx generate</code>","text":"<p>G\u00e9n\u00e9rer un composant de votre projet.</p> Bash<pre><code>fletx generate &lt;type&gt; &lt;nom&gt; [options]\n</code></pre> <p>o\u00f9 <code>&lt;type&gt;</code> peut \u00eatre : <code>controller</code>, <code>service</code>, <code>model</code>, <code>component</code>, <code>page</code></p>"},{"location":"drafts/fletxcli/#options_1","title":"Options","text":"Option Description Par d\u00e9faut <code>--output-dir OUTPUT_DIR</code> Dossier de sortie bas\u00e9 sur le type <code>--template TEMPLATE</code> Mod\u00e8le sp\u00e9cifique \u00e0 utiliser bas\u00e9 sur le type <code>--overwrite</code> \u00c9crase les fichiers existants <code>--with-test</code> G\u00e9n\u00e8re un fichier de test pour le composant"},{"location":"drafts/fletxcli/#fletx-run","title":"<code>fletx run</code>","text":"<p>Ex\u00e9cutez votre projet FletX.</p> Bash<pre><code>fletx run [target] [options]\n</code></pre> <p>o\u00f9 <code>target</code> est le fichier Python \u00e0 ex\u00e9cuter (par d\u00e9faut : <code>main.py</code>)</p>"},{"location":"drafts/fletxcli/#options_2","title":"Options","text":"Option Description Par d\u00e9faut <code>--host HOST</code> H\u00f4te de liaison <code>localhost</code> <code>--port PORT</code> Port de liaison <code>8550</code> <code>--debug</code> Mode debug <code>--watch</code> Active le hot reload (surveillance des fichiers) <code>--web</code> Ouvre dans un navigateur web <code>--desktop</code> Force le mode desktop <code>--android</code> Ouvre sur un appareil Android <code>--ios</code> Ouvre sur un appareil iOS <code>--assets-dir ASSETS_DIR</code> Dossier des assets <code>--ignore-dir IGNORE_DIR</code> Dossier \u00e0 ignorer <code>--env ENV</code> Variables d'environnement <code>KEY=VALUE</code> <code>--requirements REQUIREMENTS</code> Fichier <code>requirements.txt</code> \u00e0 utiliser <code>--install-deps</code> Installe les d\u00e9pendances avant d'ex\u00e9cuter <code>--verbose</code> Affiche des logs d\u00e9taill\u00e9s"},{"location":"drafts/fletxcli/#exemple-creation-et-execution","title":"Exemple : Cr\u00e9ation et ex\u00e9cution","text":"Bash<pre><code># Cr\u00e9er un projet\nfletx new mon_projet --author \"Jean Dupont\" --description \"Mon app FletX\"\n\n# G\u00e9n\u00e9rer un contr\u00f4leur\nfletx generate controller MonControleur --with-test\n\n# Ex\u00e9cuter le projet\nfletx run --web --debug\n</code></pre>"},{"location":"drafts/fletxcli/#fletx-cli-documentation_1","title":"\ud83c\uddec\ud83c\udde7 FletX CLI - Documentation","text":""},{"location":"drafts/fletxcli/#introduction_1","title":"Introduction","text":"<p>The FletX CLI (<code>fletx</code>) is a command-line tool that makes it easy to manage FletX projects. It lets you:</p> <ul> <li>Create a new FletX project</li> <li>Generate components (controllers, services, pages, etc.)</li> <li>Run your project with various options</li> </ul>"},{"location":"drafts/fletxcli/#main-command","title":"Main command","text":"Bash<pre><code>fletx &lt;command&gt; [options]\n</code></pre>"},{"location":"drafts/fletxcli/#available-commands","title":"Available commands","text":"Category Command Description Project Management <code>new</code> Create a new FletX project from template Code Generation <code>generate</code> Generate components like controllers, services, etc. Utilities <code>run</code> Run a FletX project with various options <p>\ud83d\udc49 Specific help :</p> Bash<pre><code>fletx &lt;command&gt; --help\nfletx help &lt;command&gt;\n</code></pre>"},{"location":"drafts/fletxcli/#fletx-new_1","title":"<code>fletx new</code>","text":"<p>Create a new FletX project.</p> Bash<pre><code>fletx new &lt;project_name&gt; [options]\n</code></pre>"},{"location":"drafts/fletxcli/#options_3","title":"Options","text":"Option Description Default <code>--template TEMPLATE</code> Template to use for the project <code>project</code> <code>--directory DIRECTORY</code> Directory where the project will be created current directory <code>--author AUTHOR</code> Author name for the project <code>--description DESCRIPTION</code> Project description <code>--version VERSION</code> Initial version of the project <code>0.1.0</code> <code>--python-version PYTHON_VERSION</code> Minimum required Python version <code>3.12</code> <code>--overwrite</code> Overwrite existing files if they exist <code>--no-install</code> Don't install dependencies after creating the project"},{"location":"drafts/fletxcli/#fletx-generate_1","title":"<code>fletx generate</code>","text":"<p>Generate a component for your project.</p> Bash<pre><code>fletx generate &lt;type&gt; &lt;name&gt; [options]\n</code></pre> <p>where <code>&lt;type&gt;</code> can be: <code>controller</code>, <code>service</code>, <code>model</code>, <code>component</code>, <code>page</code></p>"},{"location":"drafts/fletxcli/#options_4","title":"Options","text":"Option Description Default <code>--output-dir OUTPUT_DIR</code> Output directory based on type <code>--template TEMPLATE</code> Specific template to use based on type <code>--overwrite</code> Overwrite existing files <code>--with-test</code> Generate a test file for the component"},{"location":"drafts/fletxcli/#fletx-run_1","title":"<code>fletx run</code>","text":"<p>Run your FletX project.</p> Bash<pre><code>fletx run [target] [options]\n</code></pre> <p>where <code>target</code> is the Python file to run (default: <code>main.py</code>)</p>"},{"location":"drafts/fletxcli/#options_5","title":"Options","text":"Option Description Default <code>--host HOST</code> Host to bind to <code>localhost</code> <code>--port PORT</code> Port to bind to <code>8550</code> <code>--debug</code> Run in debug mode <code>--watch</code> Enable hot reload (directory watch) <code>--web</code> Open in a web browser <code>--desktop</code> Force desktop mode <code>--android</code> Open on an Android device <code>--ios</code> Open on an iOS device <code>--assets-dir ASSETS_DIR</code> Path to assets directory <code>--ignore-dir IGNORE_DIR</code> Path to ignore directory <code>--env ENV</code> Environment variables <code>KEY=VALUE</code> <code>--requirements REQUIREMENTS</code> Path to <code>requirements.txt</code> file <code>--install-deps</code> Install dependencies before running <code>--verbose</code> Verbose output"},{"location":"drafts/fletxcli/#example-create-and-run","title":"Example: Create and run","text":"Bash<pre><code># Create a project\nfletx new my_project --author \"John Doe\" --description \"My FletX app\"\n\n# Generate a controller\nfletx generate controller MyController --with-test\n\n# Run the project\nfletx run --web --debug\n</code></pre>"},{"location":"drafts/fletxservice/","title":"FletXService","text":"<p>Example Usage Python<pre><code># Exemple d'impl\u00e9mentation concr\u00e8te\nclass APIService(FletXService):\n    \"\"\"Exemple de service API utilisant FletXService\"\"\"\n\n    def __init__(self, base_url: str, **kwargs):\n        self.base_url = base_url\n        super().__init__(**kwargs)\n\n    def on_start(self):\n        \"\"\"Initialisation du service API\"\"\"\n        self.set_data('base_url', self.base_url)\n        self.log_info(f\"API Service initialized with base URL: {self.base_url}\")\n\n    async def fetch_data(self, endpoint: str) -&gt; Dict[str, Any]:\n        \"\"\"Exemple de m\u00e9thode utilisant le client HTTP\"\"\"\n        if not self.is_ready:\n            raise RuntimeError(\"Service not ready\")\n\n        if self.http_client:\n            # Utilisation du client HTTP FletX\n            url = f\"{self.base_url}/{endpoint}\"\n            response = await self.http_client.get(url)\n            return response\n        else:\n            # Simulation sans client HTTP\n            self.log_info(f\"Fetching data from {endpoint}\")\n            return {\"data\": f\"Mock data from {endpoint}\"}\n\n\n# Exemple d'utilisation\nif __name__ == \"__main__\":\n    # Service synchrone\n    api_service = APIService(\"https://api.example.com\", name=\"ExampleAPI\")\n\n    # Ajouter des listeners\n    api_service.on('ready', lambda _: print(\"Service is ready!\"))\n    api_service.on('error', lambda error: print(f\"Service error: {error}\"))\n\n    print(api_service)\n    print(f\"Is ready: {api_service.is_ready}\")\n    print(f\"Data: {api_service.data}\")\n</code></pre></p>"},{"location":"drafts/index1/","title":"Index1","text":""},{"location":"drafts/index1/#welcome-to-fletx","title":"\u2728 Welcome to FletX","text":"<ul> <li> <p> Get Started</p> <p>Set up EasySwitch and make your first API call in minutes.</p> <p>-&gt; Installation Guide</p> </li> <li> <p> API Reference</p> <p>Complete reference for all available methods and configurations.</p> <p>-&gt; API Documentation</p> </li> <li> <p> Payment Guides</p> <p>Learn how to process mobile money payments across different providers.</p> <p>-&gt; Send Payments | -&gt; Webhooks</p> </li> <li> <p> Contribute</p> <p>Help improve EasySwitch with your contributions and feedback.</p> <p>-&gt; Contribution Guide</p> </li> </ul>"},{"location":"drafts/index1/#what-is-fletx","title":"\u2728 What is FletX?","text":"<p>FletX is a lightweight, modular, and reactive architectural framework built on top of Flet, designed to help you build scalable Python UI applications with clean code, structured layers, and modern development patterns.</p> <p>Inspired by frameworks like GetX in the Flutter ecosystem, FletX brings separation of concerns, dependency injection, reactive state management, and declarative routing to Flet \u2014 without adding unnecessary complexity.</p>"},{"location":"drafts/index1/#why-fletx","title":"\u2728 Why FletX?","text":"<p>While Flet offers a powerful UI toolkit in Python, larger apps quickly become hard to maintain without a solid architecture. FletX solves that by introducing:</p> <ul> <li>\u2705 Reactive state management </li> <li>\u2705 Modular routing system with dynamic parameters and guards  </li> <li>\u2705 Controllers and services to separate logic from UI  </li> <li>\u2705 Global and local dependency injection </li> <li>\u2705 Lifecycle hooks for pages and the app  </li> <li>\u2705 Unified configuration with fluent API </li> <li>\u2705 Built-in support for asynchronous programming </li> </ul>"},{"location":"drafts/index1/#philosophy","title":"\ud83e\udde0 Philosophy","text":"<p>FletX is built on 3 principles:</p> <ol> <li>Simplicity \u2014 Focus on code clarity and maintainability.</li> <li>Modularity \u2014 Encourage component-based structure and reusable logic.</li> <li>Flexibility \u2014 Allow full control over your app flow, while staying non-intrusive.</li> </ol> <p>FletX is not a UI library. It doesn\u2019t reinvent Flet\u2019s widgets \u2014 it empowers you to use them better by providing a powerful and extensible application layer.</p> <p>Explore further:</p> <ul> <li>GitHub Repository for source code and issues</li> <li>PyPI Package for latest releases</li> <li>Community Forum (coming soon) for support and discussions</li> </ul>"},{"location":"drafts/index1/#quick-example","title":"Quick Example","text":"Python<pre><code>import flet as ft\n\nfrom fletx.app import FletXApp\nfrom fletx.core import (\n    FletXPage, FletXController, RxInt, RxStr\n)\nfrom fletx.navigation import router_config\nfrom fletx.decorators import (\n    simple_reactive\n)\n\n\nclass CounterController(FletXController):\n\n    def __init__(self):\n        count = RxInt(0)  # Reactive state\n        super().__init__()\n\n\n@simple_reactive(\n    bindings={\n        'value': 'text'\n    }\n)\nclass MyReactiveText(ft.Text):\n\n    def __init__(self, rx_text: RxStr, **kwargs):\n        self.text: RxStr = rx_text\n        super().__init__(**kwargs)\n\nclass CounterPage(FletXPage):\n    ctrl = CounterController()\n\n    def build(self):\n        return ft.Column(\n            controls = [\n                MyReactiveText(rx_text=self.ctrl.count, size=200, weight=\"bold\"),\n                ft.ElevatedButton(\n                    \"Increment\",\n                    on_click = lambda e: self.ctrl.count.increment()  # Auto UI update\n                )\n            ]\n        )\n\n\ndef main():\n\n    # Defining route\n    router_config.add_route(\n        **{'path': '/', 'component': CounterPage}\n    )\n    app = FletXApp(\n        title = \"My Counter\",\n        initial_route = \"/\",\n        debug = True\n    ).with_window_size(400, 600).with_theme(\n        ft.Theme(color_scheme_seed=ft.Colors.BLUE)\n    )\n\n    # Run sync\n    app.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"getting-started/architecture/","title":"Architecture","text":"<p>TL;DR \u2014 FletX apps separate concerns into Pages (UI), Controllers (logic + state), and Services (reusable utilities). Data flows in one direction: user action \u2192 controller \u2192 state update \u2192 UI re-render.</p>"},{"location":"getting-started/architecture/#problem","title":"Problem","text":"<p>Without clear architecture, your Flet app quickly becomes a mess:</p> <ul> <li>UI code and business logic are tangled together</li> <li>State lives in random places (widget properties, global variables, controller fields)</li> <li>Reusing logic across pages is hard</li> <li>Testing is painful because everything is interdependent</li> </ul>"},{"location":"getting-started/architecture/#solution","title":"Solution","text":"<p>FletX provides a modular, reactive architecture inspired by separation of concerns and dependency injection. It gives you a clear place for everything:</p> <ul> <li>Pages = declarative UI</li> <li>Controllers = business logic + reactive state</li> <li>Services = shared utilities (API, database, caching)</li> </ul>"},{"location":"getting-started/architecture/#progression-understanding-the-flow","title":"Progression: understanding the flow","text":"<p>We'll go from the simplest case (no logic) \u2192 single controller \u2192 multiple controllers \u2192 services. All examples are real code you can run.</p>"},{"location":"getting-started/architecture/#1-a-page-with-no-logic-ui-only","title":"1. A page with no logic (UI only)","text":"<p>When: Simple display-only pages, like a splash screen or about page.</p> Python<pre><code>from fletx.core import FletXPage\nimport flet as ft\n\nclass AboutPage(FletXPage):\n    def build(self):\n        return ft.Column([\n            ft.Text(\"About FletX\", size=30, weight=\"bold\"),\n            ft.Text(\"FletX is a framework for building structured Flet apps.\"),\n        ])\n</code></pre> <p>That's it. No state, no logic. Just UI.</p>"},{"location":"getting-started/architecture/#2-a-page-with-a-simple-controller","title":"2. A page with a simple controller","text":"<p>When: The page needs state (counters, form fields, toggles).</p> Python<pre><code>from fletx.core import FletXController, RxInt\nfrom fletx.decorators.widgets import obx\nimport flet as ft\n\nclass CounterController(FletXController):\n    def __init__(self):\n        self.count = RxInt(0)\n        super().__init__()\n\n    def increment(self):\n        self.count.value += 1\n\n    def decrement(self):\n        self.count.value -= 1\n</code></pre> <p>Explanation: The controller holds reactive state (<code>self.count</code>). Methods like <code>increment()</code> modify it. FletX tracks reads of <code>self.count</code>, so any widget that depends on it will rebuild automatically.</p> Python<pre><code>from fletx.core import FletXPage\n\nclass CounterPage(FletXPage):\n    ctrl = CounterController()\n\n    def build(self):\n        return ft.Column([\n            self._counter_text(),\n            ft.Row([\n                ft.ElevatedButton(\"-\", on_click=lambda _: self.ctrl.decrement()),\n                ft.ElevatedButton(\"+\", on_click=lambda _: self.ctrl.increment()),\n            ])\n        ])\n\n    @obx\n    def _counter_text(self):\n        # Rebuilds when self.ctrl.count changes\n        return ft.Text(\n            value=f\"Count: {self.ctrl.count.value}\",\n            size=40,\n            weight=\"bold\"\n        )\n</code></pre> <p>Key insight: The <code>@obx</code> decorator wraps a builder function. When you read <code>self.ctrl.count</code> inside it, FletX remembers that dependency. When <code>count</code> changes, the builder runs again and the widget updates.</p>"},{"location":"getting-started/architecture/#3-controller-with-business-logic","title":"3. Controller with business logic","text":"<p>When: Page needs to compute values, fetch data, or handle complex logic.</p> Python<pre><code>from fletx.core import FletXController, RxStr, RxList\nfrom fletx.decorators.reactive import reactive_debounce, reactive_memo\nfrom fletx.core.state import Computed\n\nclass SearchController(FletXController):\n    def __init__(self):\n        self.query = RxStr(\"\")\n        self.all_items = [\"Apple\", \"Apricot\", \"Avocado\", \"Banana\", \"Blueberry\"]\n        self.results = RxList([])\n        super().__init__()\n\n    @reactive_memo(maxsize=32)\n    def _filter_items(self, q: str):\n        # Pure computation: filter items matching q\n        # FletX caches this automatically\n        if not q:\n            return self.all_items\n        return [item for item in self.all_items if q.lower() in item.lower()]\n\n    @reactive_debounce(0.3)\n    def search(self, q: RxStr):\n        # Executes 300ms after user stops typing\n        self.results.value = self._filter_items(q.value)\n\n    def clear_search(self):\n        self.query.value = \"\"\n        self.results.value = []\n</code></pre> <p>Explanation:</p> <ul> <li><code>@reactive_memo</code> caches expensive computations.</li> <li><code>@reactive_debounce</code> waits for the user to pause before searching.</li> <li>The controller encapsulates all the logic; the page is just UI.</li> </ul> Python<pre><code>from fletx.core import FletXPage\nfrom fletx.decorators.widgets import obx\nimport flet as ft\n\nclass SearchPage(FletXPage):\n    ctrl = SearchController()\n\n    def build(self):\n        return ft.Column([\n            ft.TextField(\n                label=\"Search\",\n                on_change=lambda e: (\n                    self.ctrl.query.value = e.control.value,\n                    self.ctrl.search(self.ctrl.query)\n                )[0]\n            ),\n            self._results_list(),\n        ])\n\n    @obx\n    def _results_list(self):\n        # Rebuilds when self.ctrl.results changes\n        items = self.ctrl.results.value\n        if not items:\n            return ft.Text(\"No results\")\n        return ft.Column([\n            ft.Text(item) for item in items\n        ])\n</code></pre>"},{"location":"getting-started/architecture/#4-multiple-pages-sharing-a-controller","title":"4. Multiple pages sharing a controller","text":"<p>When: Multiple pages need access to the same state (e.g., user profile, app settings).</p> Python<pre><code>from fletx import FletX\nfrom fletx.core import FletXController, RxDict, RxBool\n\nclass AppController(FletXController):\n    \"\"\"Shared app-wide state\"\"\"\n    def __init__(self):\n        self.user = RxDict({})\n        self.is_logged_in = RxBool(False)\n        super().__init__()\n\n    def login(self, email, password):\n        # Validate and set user\n        self.user.value = {\"email\": email, \"name\": \"John\"}\n        self.is_logged_in.value = True\n\n    def logout(self):\n        self.user.value = {}\n        self.is_logged_in.value = False\n\n# Register a global instance of the controller\nFletX.put(AppController, tag='app_ctrl')\n</code></pre> <p>Use it from multiple pages:</p> Python<pre><code>from fletx import FletX\nfrom fletx.core import FletXPage\n\nclass ProfilePage(FletXPage):\n    # Get the global iinstance of AppController \n    app_ctrl = FletX.find(AppController, tag='app_ctrl')\n\n    def build(self):\n        return ft.Column([\n            self._profile_view(),\n            ft.ElevatedButton(\"Logout\", on_click=lambda _: self.app_ctrl.logout())\n        ])\n\n    @obx\n    def _profile_view(self):\n        if not self.app_ctrl.is_logged_in.value:\n            return ft.Text(\"Not logged in\")\n        user = self.app_ctrl.user.value\n        return ft.Text(f\"Welcome, {user.get('name', 'Guest')}\")\n</code></pre> Python<pre><code>from fletx import FletX\nclass SettingsPage(FletXPage):\n    # Get the global instance of AppController\n    app_ctrl = FletX.put(AppController, tag='app_ctrl')\n\n    def build(self):\n        return ft.Column([\n            ft.Text(f\"Logged in as: {self.app_ctrl.user.value.get('email', 'N/A')}\")\n        ])\n</code></pre> <p>Key: Both pages share the same <code>AppController</code> instance. When one page changes <code>is_logged_in</code>, all pages see the change.</p>"},{"location":"getting-started/architecture/#5-services-for-reusable-logic","title":"5. Services for reusable logic","text":"<p>When: You need to share utilities across multiple controllers (API calls, database, caching, file I/O).</p> Python<pre><code>from fletx.core import FletXService, RxDict, RxBool\n\nclass UserService(FletXService):\n    \"\"\"Manages user data\"\"\"\n    def __init__(self):\n        super().__init__()\n        self.user = RxDict({})\n        self.is_loading = RxBool(False)\n\n    def fetch_user(self, user_id: int):\n        \"\"\"Simulate API call\"\"\"\n        self.is_loading.value = True\n        try:\n            # In real code: response = requests.get(f\"/api/users/{user_id}\")\n            self.user.value = {\n                \"id\": user_id,\n                \"name\": \"John Doe\",\n                \"email\": \"john@example.com\"\n            }\n        finally:\n            self.is_loading.value = False\n</code></pre> <p>Use service from a controller:</p> Python<pre><code>from fletx.core import FletXController\n\nclass ProfileController(FletXController):\n    def __init__(self):\n        # Find the service from FletX's dependency injection\n        self.user_service = FletX.find(UserService)\n        super().__init__()\n\n    def load_profile(self, user_id: int):\n        self.user_service.fetch_user(user_id)\n</code></pre> <p>Use service from a page:</p> Python<pre><code>from fletx.core import FletXPage\nfrom fletx import FletX\n\nclass ProfilePage(FletXPage):\n    def build(self):\n        user_service = FletX.find(UserService)\n\n        return ft.Column([\n            self._profile_view(user_service),\n        ])\n\n    @obx\n    def _profile_view(self, user_service):\n        if user_service.is_loading.value:\n            return ft.ProgressRing()\n        user = user_service.user.value\n        return ft.Column([\n            ft.Text(f\"Name: {user.get('name', 'N/A')}\"),\n            ft.Text(f\"Email: {user.get('email', 'N/A')}\")\n        ])\n</code></pre>"},{"location":"getting-started/architecture/#6-the-full-picture-app-with-routing","title":"6. The full picture: app with routing","text":"<p>Let's combine pages, controllers, services, and routing.</p> <p>Project structure:</p> Text Only<pre><code>app/\n  __init__.py\n  main.py\n  app.py\n  pages/\n    __init__.py\n    home.py\n    profile.py\n    settings.py\n  controllers/\n    __init__.py\n    home_controller.py\n    app_controller.py\n  services/\n    __init__.py\n    user_service.py\n    api_service.py\n</code></pre> <p>app/app.py \u2014 App setup with routing:</p> Python<pre><code>from fletx.app import FletXApp\nfrom fletx.navigation import router_config\nfrom app.services.user_service import UserService\nfrom app.pages.home import HomePage\nfrom app.pages.profile import ProfilePage\nfrom app.pages.settings import SettingsPage\n\n# Register services\nFletX.register(UserService)\n\n# Register routes\nrouter_config.add_routes([\n    {\"path\": \"/\", \"component\": HomePage},\n    {\"path\": \"/profile/:user_id\", \"component\": ProfilePage},\n    {\"path\": \"/settings\", \"component\": SettingsPage},\n])\n\napp = FletXApp(title=\"MyApp\")\n</code></pre> <p>app/main.py \u2014 Entry point:</p> Python<pre><code>from app.app import app\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>app/pages/home.py:</p> Python<pre><code>from fletx.core import FletXPage\nfrom app.controllers.home_controller import HomeController\nimport flet as ft\n\nclass HomePage(FletXPage):\n    ctrl = HomeController()\n\n    def build(self):\n        return ft.Column([\n            ft.Text(\"Home\", size=30, weight=\"bold\"),\n            ft.ElevatedButton(\"Go to Profile\", on_click=lambda _: self.page.go(\"/profile/123\"))\n        ])\n</code></pre> <p>app/controllers/home_controller.py:</p> Python<pre><code>from fletx.core import FletXController, RxInt\n\nclass HomeController(FletXController):\n    def __init__(self):\n        self.visit_count = RxInt(0)\n        super().__init__()\n\n    def record_visit(self):\n        self.visit_count.value += 1\n</code></pre> <p>app/services/user_service.py:</p> Python<pre><code>from fletx.core import FletXService, RxDict\n\nclass UserService(FletXService):\n    def __init__(self):\n        super().__init__()\n        self.user = RxDict({})\n\n    def fetch_user(self, user_id: int):\n        self.user.value = {\"id\": user_id, \"name\": f\"User {user_id}\"}\n</code></pre>"},{"location":"getting-started/architecture/#data-flow-diagram","title":"Data flow diagram","text":"Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   User Interaction                       \u2502\n\u2502            (button click, text input, etc)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Page.build()                            \u2502\n\u2502          (renders UI from current state)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Event Handler in Page                       \u2502\n\u2502         (on_click, on_change, on_focus, etc)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Controller Method (or Service)                  \u2502\n\u2502    (implements business logic, updates state)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          State Update (RxInt, RxStr, etc)               \u2502\n\u2502          (triggers dependent watchers)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Reactive Watchers (@obx, listeners)                \u2502\n\u2502        (detect the state change)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            UI Rebuilds (only changed parts)             \u2502\n\u2502                   Page.build() again                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/architecture/#best-practices-summary","title":"Best practices (summary)","text":"Principle What to do Single responsibility One controller per page (usually). One service per concern (users, auth, API). Separate logic from UI Put business logic in controllers/services. Pages just render and call methods. Use reactive state All mutable state should be <code>Rx*</code> (RxInt, RxStr, RxList, RxDict). Never plain Python variables. Inject dependencies Use <code>FletX.find()</code> to get services, not global imports. Makes testing easy. Keep methods small Controller methods should be focused. If a method is too long, break it into smaller methods. Clean up on dispose If your service opens a connection (socket, file, etc), close it in <code>on_dispose()</code>. Use <code>@obx</code> for builders Wrap reactive builders with <code>@obx</code> so FletX tracks dependencies automatically. Avoid <code>lambda:</code> in build Use <code>@obx</code> decorated methods instead. Cleaner, easier to understand."},{"location":"getting-started/architecture/#common-patterns","title":"Common patterns","text":""},{"location":"getting-started/architecture/#pattern-1-read-only-page-no-controller-needed","title":"Pattern 1: Read-only page (no controller needed)","text":"Python<pre><code>class AboutPage(FletXPage):\n    def build(self):\n        return ft.Column([ft.Text(\"About\")])\n</code></pre>"},{"location":"getting-started/architecture/#pattern-2-single-reactive-value","title":"Pattern 2: Single reactive value","text":"Python<pre><code>class TogglePage(FletXPage):\n    is_dark = RxBool(False)\n\n    def build(self):\n        return ft.Column([\n            self._toggle(),\n        ])\n\n    @obx\n    def _toggle(self):\n        return ft.Switch(\n            value=self.is_dark.value,\n            on_change=lambda e: setattr(self.is_dark, 'value', e.control.value)\n        )\n</code></pre>"},{"location":"getting-started/architecture/#pattern-3-page-controller-service","title":"Pattern 3: Page + Controller + Service","text":"Python<pre><code>from fletx import FletX\n\nclass UserPage(FletXPage):\n    ctrl = UserController()\n\n    def build(self):\n        return ft.Column([self._user_card()])\n\n    @obx\n    def _user_card(self):\n        user_service = FletX.find(UserService)\n        return ft.Text(user_service.user.value.get(\"name\", \"Unknown\"))\n</code></pre>"},{"location":"getting-started/architecture/#troubleshooting","title":"Troubleshooting","text":"<p>Q: My widget doesn't update when state changes.</p> <p>A: Make sure you're using <code>@obx</code> and reading the reactive variable inside the builder. FletX needs to detect the read to track the dependency.</p> <p>Q: I have multiple pages sharing state, but changes don't sync.</p> <p>A: Register the controller/service with <code>FletX.register()</code> at app startup, and use <code>FletX.find()</code> to retrieve it. Don't create new instances.</p> <p>Q: My controller is getting too big.</p> <p>A: Break it into multiple smaller controllers or move logic into services. Each should have one clear responsibility.</p> <p>Q: How do I pass data between pages?</p> <p>A: Use route parameters (<code>/profile/:user_id</code>) and access them in <code>self.route_info.params</code>. Or use a shared service/controller.</p>"},{"location":"getting-started/architecture/#references","title":"References","text":"<ul> <li>Controllers \u2014 deep dive into FletXController</li> <li>State Management \u2014 understand reactive primitives (RxInt, RxList, Computed)</li> <li>Reactive Decorators \u2014 control when/how code executes (debounce, throttle, memo)</li> <li>Pages \u2014 detailed FletXPage reference</li> <li>Routing \u2014 navigation and route configuration</li> </ul> <p>Next: Pick a pattern above that matches your use case. Start with pattern 1 or 2, then graduate to 3 as you need more features.</p>"},{"location":"getting-started/controllers/","title":"Controllers","text":"<p>TL;DR: A <code>FletXController</code> is where your business logic lives. It manages reactive state (<code>create_rx_int()</code>, <code>create_rx_str()</code>, etc.), handles events (local and global), manages side effects (<code>use_effect()</code>), and communicates with your UI through reactive variables and callbacks. Controllers keep your code organized and testable.</p>"},{"location":"getting-started/controllers/#what-is-a-fletxcontroller","title":"What is a FletXController?","text":"<p>A <code>FletXController</code> is the business logic layer of your FletX application. It:</p> <ul> <li>Manages state - Reactive variables that automatically update the UI</li> <li>Handles events - Local communication between parts of the app, global communication across controllers</li> <li>Manages side effects - Code that runs when state changes</li> <li>Provides context - Shared data accessible across your application</li> <li>Organizes logic - Keeps messy business logic out of your UI code</li> </ul> <p>Think of it as the brain of a feature, while your page is the interface.</p>"},{"location":"getting-started/controllers/#why-controllers","title":"Why Controllers?","text":"<p>Without Controllers - Logic Mixed with UI:</p> Python<pre><code>import flet as ft\n\nclass CounterPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.count = 0\n\n    def build(self):\n        def on_increment(e):\n            self.count += 1\n            # Manual UI updates needed everywhere\n            count_text.value = str(self.count)\n            self.page_instance.update()\n\n        def on_decrement(e):\n            self.count -= 1\n            # More manual updates\n            count_text.value = str(self.count)\n            self.page_instance.update()\n\n        count_text = ft.Text(str(self.count))\n        return ft.Column([\n            count_text,\n            ft.ElevatedButton(\"+\", on_click=on_increment),\n            ft.ElevatedButton(\"-\", on_click=on_decrement)\n        ])\n</code></pre> <p>Problems:</p> <ul> <li>Logic scattered in the page</li> <li>No reusability</li> <li>Hard to test</li> <li>Manual UI updates</li> <li>Difficult to modify</li> </ul> <p>With Controllers - Clean Separation:</p> Python<pre><code>from fletx.core import FletXController, FletXPage\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass CounterController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.count = self.create_rx_int(0)\n\n    def increment(self):\n        self.count.increment()\n        self.emit_local(\"counter_changed\", self.count.value)\n\n    def decrement(self):\n        self.count.decrement()\n        self.emit_local(\"counter_changed\", self.count.value)\n\nclass CounterPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = CounterController()\n\n    @obx\n    def build(self):\n        return ft.Column([\n            ft.Text(str(self.controller.count)),\n            ft.ElevatedButton(\"+\", on_click=lambda _: self.controller.increment()),\n            ft.ElevatedButton(\"-\", on_click=lambda _: self.controller.decrement())\n        ])\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Clean separation of concerns</li> <li>\u2705 Reusable logic</li> <li>\u2705 Easy to test</li> <li>\u2705 Automatic UI updates with reactive variables</li> <li>\u2705 Event-driven communication</li> </ul>"},{"location":"getting-started/controllers/#your-first-controller","title":"Your First Controller","text":""},{"location":"getting-started/controllers/#step-1-create-a-basic-controller","title":"Step 1: Create a Basic Controller","text":"Python<pre><code>from fletx.core import FletXController\n\nclass GreetingController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.name = self.create_rx_str(\"\")\n\n    def greet(self):\n        return f\"Hello, {self.name.value}!\"\n</code></pre>"},{"location":"getting-started/controllers/#step-2-use-in-a-page","title":"Step 2: Use in a Page","text":"Python<pre><code>from fletx.core import FletXPage\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass GreetingPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = GreetingController()\n\n    @obx\n    def build(self):\n        return ft.Column([\n            ft.TextField(\n                label=\"Your name\",\n                value=self.controller.name.value,\n                on_change=lambda e: self.controller.name.set(e.control.value)\n            ),\n            ft.Text(self.controller.greet(), size=18)\n        ])\n</code></pre> <p>Done! \ud83c\udf89</p>"},{"location":"getting-started/controllers/#reactive-variables","title":"Reactive Variables","text":"<p>At the heart of controllers are reactive variables - they automatically notify the UI when they change.</p>"},{"location":"getting-started/controllers/#creating-reactive-variables","title":"Creating Reactive Variables","text":"Python<pre><code>class MyController(FletXController):\n    def __init__(self):\n        super().__init__()\n\n        # Integer\n        self.count = self.create_rx_int(0)\n\n        # String\n        self.username = self.create_rx_str(\"\")\n\n        # Boolean\n        self.is_enabled = self.create_rx_bool(False)\n\n        # List\n        self.items = self.create_rx_list([])\n\n        # Dictionary\n        self.config = self.create_rx_dict({\"theme\": \"dark\"})\n\n        # Generic reactive value\n        self.data = self.create_reactive({\"key\": \"value\"})\n</code></pre>"},{"location":"getting-started/controllers/#using-reactive-variables","title":"Using Reactive Variables","text":"Python<pre><code># Getting values\ncount_value = self.count.value\n\n# Setting values\nself.count.value = 5 \nself.username.value = \"Alice\"\nself.is_enabled.value = True\n# Or with set() method\nself.count.set(6)\nself.username.set(\"Bob\")\n\n# Working with lists\nself.items.append(\"new item\")\nself.items.extend([\"item2\", \"item3\"])\nself.items.remove(\"new item\")\nself.items.pop()\nself.items.clear()\n\n# Working with dicts\nself.config[\"theme\"] = \"light\"\nself.config.update({\"lang\": \"fr\"})\nself.config.get(\"theme\")\n\n# Special methods for specific types\nself.count.increment()  # count += 1\nself.count.decrement()  # count -= 1\nself.is_enabled.toggle()  # is_enabled = not is_enabled\nself.username.append(\" Smith\")  # append to string\nself.username.clear()  # clear string\n</code></pre>"},{"location":"getting-started/controllers/#listening-to-changes","title":"Listening to Changes","text":"Python<pre><code>class UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.email = self.create_rx_str(\"\")\n\n    def on_ready(self):\n        # Listen to email changes\n        self.email.listen(self._on_email_change)\n\n    def _on_email_change(self):\n        print(f\"Email changed to: {self.email.value}\")\n        # Validate email, send events, etc.\n</code></pre>"},{"location":"getting-started/controllers/#computed-properties","title":"Computed Properties","text":"<p>Computed properties are derived reactive values that automatically update when their dependencies change:</p> Python<pre><code>class UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.first_name = self.create_rx_str(\"John\")\n        self.last_name = self.create_rx_str(\"Doe\")\n\n        # Create computed full name\n        self.full_name = self.create_computed(\n            lambda: f\"{self.first_name.value} {self.last_name.value}\"\n        )\n\n    def on_ready(self):\n        # Listen to computed value changes\n        self.full_name.listen(lambda: print(f\"Full name: {self.full_name.value}\"))\n\n# In page\n@obx\ndef build(self):\n    return ft.Text(self.controller.full_name.value)\n    # Updates automatically when first_name or last_name changes\n</code></pre>"},{"location":"getting-started/controllers/#effects-and-side-effects","title":"Effects and Side Effects","text":"<p>Effects run code in response to state changes:</p> Python<pre><code>class DataController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.search_query = self.create_rx_str(\"\")\n        self.results = self.create_rx_list([])\n\n    def on_ready(self):\n        # Effect runs whenever search_query changes\n        self.use_effect(\n            self._perform_search,\n            deps=[self.search_query]\n        )\n\n    def _perform_search(self):\n        \"\"\"Effect function that runs on every search_query change\"\"\"\n        query = self.search_query.value\n        if query:\n            # Simulate API call\n            self.results.value = self._search_database(query)\n        else:\n            self.results.value = []\n\n    def _search_database(self, query):\n        return [f\"Result {i}\" for i in range(3)]\n</code></pre>"},{"location":"getting-started/controllers/#effects-with-cleanup","title":"Effects with Cleanup","text":"Python<pre><code>class WebsocketController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.is_connected = self.create_rx_bool(False)\n        self.ws = None\n\n    def on_ready(self):\n        self.add_effect(self._setup_websocket)\n\n    def _setup_websocket(self):\n        \"\"\"Effect with cleanup function\"\"\"\n        print(\"Connecting websocket...\")\n        self.ws = self._create_connection()\n        self.is_connected.value = True\n\n        # Return cleanup function\n        def cleanup():\n            print(\"Closing websocket...\")\n            if self.ws:\n                self.ws.close()\n            self.is_connected.value = False\n\n        return cleanup\n\n    def _create_connection(self):\n        # Simulate websocket connection\n        return {\"connected\": True}\n</code></pre>"},{"location":"getting-started/controllers/#local-event-bus","title":"Local Event Bus","text":"<p>Local events allow communication within a controller or between related controllers:</p> Python<pre><code>class CartController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.items = self.create_rx_list([])\n        self.total = self.create_rx_int(0)\n\n    def add_item(self, item, price):\n        self.items.append(item)\n        self.total.value += price\n        # Emit event\n        self.emit_local(\"item_added\", {\"item\": item, \"price\": price})\n\n    def remove_item(self, item):\n        self.items.remove(item)\n        # Emit event\n        self.emit_local(\"item_removed\", {\"item\": item})\n\nclass CartPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = CartController()\n\n    def on_init(self):\n        # Listen to controller events\n        self.controller.on_local(\"item_added\", self._on_item_added)\n        self.controller.on_local(\"item_removed\", self._on_item_removed)\n\n    def _on_item_added(self, event):\n        print(f\"Item added: {event.data['item']}\")\n\n    def _on_item_removed(self, event):\n        print(f\"Item removed: {event.data['item']}\")\n</code></pre>"},{"location":"getting-started/controllers/#event-bus-methods","title":"Event Bus Methods","text":"Python<pre><code># Emit events\ncontroller.emit_local(\"user_logged_in\", {\"username\": \"john\"})\n\n# Listen to events\ncontroller.on_local(\"user_logged_in\", callback)\n\n# Listen only once\ncontroller.once_local(\"user_logged_in\", callback)\n\n# Stop listening\ncontroller.off_local(\"user_logged_in\", callback)\n\n# Get reactive list of all events\nevents = controller.listen_reactive_local(\"user_logged_in\")\nevents.listen(lambda: print(f\"Total events: {len(events.value)}\"))\n\n# Access event history\nlast_event = controller.event_bus.last_event.value\nall_events = controller.event_bus.event_history.value\n</code></pre>"},{"location":"getting-started/controllers/#global-event-bus","title":"Global Event Bus","text":"<p>Global events allow communication across the entire app:</p> Python<pre><code>class NotificationController(FletXController):\n    def on_ready(self):\n        # Listen to global events\n        self.on_global(\"user_logged_out\", self._on_user_logged_out)\n\n    def _on_user_logged_out(self, event):\n        print(\"User logged out globally!\")\n\nclass AuthController(FletXController):\n    def logout(self):\n        # Emit global event\n        self.emit_global(\"user_logged_out\", {})\n\n        # All controllers with listeners will be notified\n</code></pre>"},{"location":"getting-started/controllers/#global-event-methods","title":"Global Event Methods","text":"Python<pre><code># Same as local but global scope\ncontroller.emit_global(\"event_name\", data)\ncontroller.on_global(\"event_name\", callback)\ncontroller.once_global(\"event_name\", callback)\ncontroller.off_global(\"event_name\", callback)\ncontroller.listen_reactive_global(\"event_name\")\n</code></pre>"},{"location":"getting-started/controllers/#context-system","title":"Context System","text":"<p>Context provides a way to store and share data:</p>"},{"location":"getting-started/controllers/#local-context","title":"Local Context","text":"Python<pre><code>class UserProfileController(FletXController):\n    def __init__(self):\n        super().__init__()\n\n    def on_ready(self):\n        # Store in local context\n        self.set_context(\"user_id\", 123)\n        self.set_context(\"user_role\", \"admin\")\n\n        # Get from context\n        user_id = self.get_context(\"user_id\")\n\n        # Get reactive version\n        rx_role = self.get_context_reactive(\"user_role\")\n        rx_role.listen(lambda: print(f\"Role changed: {rx_role.value}\"))\n\n        # Check if exists\n        has_user = self.has_context(\"user_id\")\n\n        # Update multiple\n        self.update_context(\n            user_id=124,\n            user_role=\"user\"\n        )\n\n        # Remove\n        self.remove_context(\"user_role\")\n</code></pre>"},{"location":"getting-started/controllers/#global-context","title":"Global Context","text":"Python<pre><code>class ThemeController(FletXController):\n    def set_theme(self, theme):\n        # Store globally - accessible from all controllers\n        self.set_global_context(\"current_theme\", theme)\n\nclass AnyOtherController(FletXController):\n    def on_ready(self):\n        # Access global context\n        theme = self.get_global_context(\"current_theme\")\n\n        # Get reactive version\n        rx_theme = self.get_global_context_reactive(\"current_theme\")\n        rx_theme.listen(lambda: print(f\"Theme changed: {rx_theme.value}\"))\n</code></pre>"},{"location":"getting-started/controllers/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Controllers go through lifecycle stages:</p> Text Only<pre><code>CREATED \u2192 INITIALIZED \u2192 READY \u2192 DISPOSED\n</code></pre>"},{"location":"getting-started/controllers/#lifecycle-methods","title":"Lifecycle Methods","text":"Python<pre><code>class FullLifecycleController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.data = self.create_rx_str(\"initial\")\n\n    def on_initialized(self):\n        \"\"\"Called when controller is created and initialized\"\"\"\n        print(\"Controller initialized\")\n\n    def on_ready(self):\n        \"\"\"Called when controller is ready (page is showing)\"\"\"\n        print(\"Controller ready\")\n        # Setup listeners, load data\n        self.load_data()\n\n    def on_disposed(self):\n        \"\"\"Called when controller is destroyed\"\"\"\n        print(\"Controller disposed\")\n        # Cleanup, cancel requests, close connections\n\n    def load_data(self):\n        # Load initial data\n        self.data.value = \"loaded\"\n</code></pre>"},{"location":"getting-started/controllers/#built-in-state","title":"Built-in State","text":"<p>Controllers include common reactive state:</p> Python<pre><code>class ApiController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.api_data = self.create_rx_list([])\n\n    def fetch_data(self):\n        # Use built-in state\n        self.set_loading(True)\n        self.clear_error()\n\n        try:\n            # Simulate API call\n            data = self._call_api()\n            self.api_data.value = data\n        except Exception as e:\n            self.set_error(str(e))\n        finally:\n            self.set_loading(False)\n\n    def _call_api(self):\n        return [{\"id\": 1, \"name\": \"Item\"}]\n\n# In page\nclass DataPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = ApiController()\n\n    @obx\n    def build(self):\n        if self.controller.is_loading:\n            return ft.ProgressRing()\n\n        if self.controller.error_message:\n            return ft.Text(f\"Error: {self.controller.error_message}\")\n\n        return ft.Column([\n            ft.Text(f\"Items: {len(self.controller.api_data)}\")\n        ])\n</code></pre> Built-in State Type Purpose <code>is_loading</code> RxBool Shows if operation is ongoing <code>error_message</code> RxStr Holds error messages <code>state</code> RxDict General purpose state storage"},{"location":"getting-started/controllers/#parent-child-controllers","title":"Parent-Child Controllers","text":"<p>Organize complex features with nested controllers:</p> Python<pre><code>class ParentController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.child1 = ChildController()\n        self.child2 = ChildController()\n\n        # Register children\n        self.add_child(self.child1)\n        self.add_child(self.child2)\n\n    def dispose(self):\n        # Children are automatically disposed\n        super().dispose()\n\nclass ChildController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.name = self.create_rx_str(\"\")\n</code></pre>"},{"location":"getting-started/controllers/#complete-real-world-example","title":"Complete Real-World Example","text":"Python<pre><code>from fletx.core import FletXController, FletXPage\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass TodoController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.todos = self.create_rx_list([])\n        self.filter_type = self.create_rx_str(\"all\")  # all, completed, pending\n\n        # Computed filtered todos\n        self.filtered_todos = self.create_computed(\n            self._compute_filtered\n        )\n\n        # Computed stats\n        self.completed_count = self.create_computed(\n            lambda: len([t for t in self.todos if t[\"done\"]])\n        )\n        self.total_count = self.create_computed(\n            lambda: len(self.todos)\n        )\n\n    def _compute_filtered(self):\n        if self.filter_type.value == \"completed\":\n            return [t for t in self.todos if t[\"done\"]]\n        elif self.filter_type.value == \"pending\":\n            return [t for t in self.todos if not t[\"done\"]]\n        return list(self.todos.value)\n\n    def on_ready(self):\n        # Load initial todos\n        self.load_todos()\n\n        # Listen for changes\n        self.on_local(\"todo_added\", lambda e: self.emit_global(\"todos_changed\", None))\n\n    def load_todos(self):\n        self.set_loading(True)\n        try:\n            self.todos.value = [\n                {\"id\": 1, \"title\": \"Learn FletX\", \"done\": False},\n                {\"id\": 2, \"title\": \"Build app\", \"done\": False},\n                {\"id\": 3, \"title\": \"Deploy\", \"done\": False}\n            ]\n        finally:\n            self.set_loading(False)\n\n    def add_todo(self, title):\n        new_todo = {\n            \"id\": len(self.todos) + 1,\n            \"title\": title,\n            \"done\": False\n        }\n        self.todos.append(new_todo)\n        self.emit_local(\"todo_added\", new_todo)\n\n    def toggle_todo(self, todo_id):\n        for todo in self.todos.value:\n            if todo[\"id\"] == todo_id:\n                todo[\"done\"] = not todo[\"done\"]\n                self.todos.value = list(self.todos.value)  # Trigger update\n                break\n\n    def delete_todo(self, todo_id):\n        self.todos.value = [t for t in self.todos if t[\"id\"] != todo_id]\n\n    def set_filter(self, filter_type):\n        self.filter_type.value = filter_type\n\nclass TodoPage(FletXPage):\n    def __init__(self):\n        super().__init__(padding=20)\n        self.controller = TodoController()\n        self.input_field = ft.TextField(label=\"Add new todo\")\n\n    def on_init(self):\n        self.controller.on_local(\"todo_added\", self._on_todo_added)\n\n    def _on_todo_added(self, event):\n        self.input_field.value = \"\"\n        self.refresh()\n\n    @obx\n    def build(self):\n        if self.controller.is_loading:\n            return ft.Center(content=ft.ProgressRing())\n\n        return ft.Column([\n            # Header\n            ft.Text(\n                f\"My Todos ({self.controller.completed_count}/{self.controller.total_count})\",\n                size=24,\n                weight=\"bold\"\n            ),\n\n            # Input\n            ft.Row([\n                ft.TextField(\n                    ref=self.input_field,\n                    label=\"Add new todo\",\n                    expand=True,\n                ),\n                ft.IconButton(\n                    ft.icons.ADD,\n                    on_click=lambda _: self.controller.add_todo(self.input_field.value)\n                )\n            ]),\n\n            # Filter buttons\n            ft.Row([\n                ft.TextButton(\n                    \"All\",\n                    on_click=lambda _: self.controller.set_filter(\"all\")\n                ),\n                ft.TextButton(\n                    \"Pending\",\n                    on_click=lambda _: self.controller.set_filter(\"pending\")\n                ),\n                ft.TextButton(\n                    \"Completed\",\n                    on_click=lambda _: self.controller.set_filter(\"completed\")\n                )\n            ]),\n\n            # Todo list\n            ft.ListView([\n                ft.ListTile(\n                    title=ft.Text(todo[\"title\"]),\n                    leading=ft.Checkbox(\n                        value=todo[\"done\"],\n                        on_change=lambda _: self.controller.toggle_todo(todo[\"id\"])\n                    ),\n                    trailing=ft.IconButton(\n                        ft.icons.DELETE,\n                        on_click=lambda _: self.controller.delete_todo(todo[\"id\"])\n                    )\n                )\n                for todo in self.controller.filtered_todos\n            ])\n        ], scroll=ft.ScrollMode.AUTO)\n</code></pre>"},{"location":"getting-started/controllers/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/controllers/#1-use-create_rx_-for-initialization","title":"1. Use <code>create_rx_*()</code> for Initialization","text":"Python<pre><code># \u2705 Good\nclass MyController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.count = self.create_rx_int(0)\n\n# \u274c Avoid - don't import and use directly\nfrom fletx.core.state import RxInt\nclass MyController(FletXController):\n    def __init__(self):\n        self.count = RxInt(0)  # Wrong!\n</code></pre>"},{"location":"getting-started/controllers/#2-initialize-in-on_ready-not-__init__","title":"2. Initialize in <code>on_ready()</code>, not <code>__init__()</code>","text":"Python<pre><code># \u2705 Good - setup in on_ready\ndef on_ready(self):\n    self.load_data()\n    self.email.listen(self._validate_email)\n\n# \u274c Avoid - setup in __init__\ndef __init__(self):\n    self.load_data()  # May not work correctly\n</code></pre>"},{"location":"getting-started/controllers/#3-use-computed-for-derived-values","title":"3. Use Computed for Derived Values","text":"Python<pre><code># \u2705 Good - use computed\nself.full_name = self.create_computed(\n    lambda: f\"{self.first} {self.last}\"\n)\n\n# \u274c Avoid - manual updates\nself.full_name = self.create_rx_str(\"\")\nself.first.listen(lambda: self.full_name.value = f\"{self.first.value} {self.last.value}\")\n</code></pre>"},{"location":"getting-started/controllers/#4-clean-up-in-lifecycle","title":"4. Clean Up in Lifecycle","text":"Python<pre><code>def on_disposed(self):\n    # Cancel requests\n    self.cancel_pending()\n\n    # Close connections\n    if self.websocket:\n        self.websocket.close()\n</code></pre>"},{"location":"getting-started/controllers/#5-use-events-for-communication","title":"5. Use Events for Communication","text":"Python<pre><code># \u2705 Good - use events\nself.emit_local(\"data_changed\", new_data)\n\n# \u274c Avoid - tight coupling\npage.controller.do_something()  # Page depends on controller structure\n</code></pre>"},{"location":"getting-started/controllers/#summary","title":"Summary","text":"Feature Purpose <code>create_rx_int()</code> Create reactive integer <code>create_rx_str()</code> Create reactive string <code>create_rx_bool()</code> Create reactive boolean <code>create_rx_list()</code> Create reactive list <code>create_rx_dict()</code> Create reactive dictionary <code>create_computed()</code> Create derived reactive value <code>use_effect()</code> Run code on state changes <code>add_effect()</code> Add effect with cleanup <code>emit_local()</code> Emit local event <code>emit_global()</code> Emit global event <code>on_local()</code> Listen to local event <code>on_global()</code> Listen to global event <code>set_context()</code> Store local context value <code>get_context()</code> Get local context value <code>get_context_reactive()</code> Get local context as reactive <code>set_global_context()</code> Store global context value <code>get_global_context()</code> Get global context value <code>set_loading()</code> Set loading state <code>set_error()</code> Set error message <code>on_initialized()</code> Lifecycle hook - initialization <code>on_ready()</code> Lifecycle hook - ready <code>on_disposed()</code> Lifecycle hook - cleanup"},{"location":"getting-started/controllers/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Pages to use controllers in UI</li> <li>Explore Routing to share controllers across pages</li> <li>Understand Dependency Injection to manage controller lifecycles</li> <li>Read about State Management for advanced patterns</li> <li>Check Decorators for reactive UI with <code>@obx</code></li> </ul>"},{"location":"getting-started/decorators/","title":"Reactive Decorators","text":"<p>TL;DR \u2014 Decorators that let you control precisely how and when reactive code executes.</p>"},{"location":"getting-started/decorators/#problem","title":"Problem","text":"<p>When you write reactive UI code, you quickly face challenges:</p> <ul> <li>A value changes 10 times in 100ms \u2192 10 recomputations instead of 1</li> <li>User search triggers an API request on every keystroke</li> <li>An effect function subscribes 50 times to the same event</li> <li>Code runs even when its conditions no longer apply</li> </ul>"},{"location":"getting-started/decorators/#solution","title":"Solution","text":"<p>FletX provides a toolkit of decorators that factorize recurring patterns. Use them to debounce, throttle, memoize, batch, filter, and structure your reactive effects.</p>"},{"location":"getting-started/decorators/#progression-simple-advanced","title":"Progression: simple \u2192 advanced","text":"<p>We'll progress from simple use cases (5 min) to sophisticated patterns (20 min). All examples use real APIs from <code>fletx/decorators/*</code>.</p>"},{"location":"getting-started/decorators/#1-batch-updates-reactive_batch","title":"1. Batch updates: <code>@reactive_batch()</code>","text":"<p>When to use it: You mutate an <code>RxList</code> or multiple <code>Reactive</code> values in quick succession, and you want one UI update instead of many.</p> <p>Example:</p> Python<pre><code>from fletx.decorators import reactive_batch\nfrom fletx.core.state import RxList\n\nitems = RxList([])\n\n@reactive_batch()\ndef refresh_ui():\n    print('Updating UI with:', items.value)\n\n# Add 3 items quickly\nitems.append('user1')\nitems.append('user2')\nitems.append('user3')\n# refresh_ui() runs ONCE on the next tick (not 3 times)\n</code></pre> <p>Tip: Keep <code>refresh_ui()</code> small and without heavy side effects. It's just a grouper.</p>"},{"location":"getting-started/decorators/#2-wait-for-a-pause-reactive_debouncedelay","title":"2. Wait for a pause: <code>@reactive_debounce(delay)</code>","text":"<p>When to use it: User input (search box), API calls, heavy computations triggered by the user.</p> <p>Example:</p> Python<pre><code>from fletx.decorators import reactive_debounce\nfrom fletx.core.state import RxStr\n\nsearch_query = RxStr(\"\")\n\n@reactive_debounce(0.4)  # wait 400ms of silence\ndef perform_search(q: RxStr):\n    print(f\"Searching for: {q.value}\")\n    # API call here...\n\n# User types: s -&gt; e -&gt; a -&gt; r -&gt; c -&gt; h\n# perform_search() is called only once, 400ms after user stops typing\n</code></pre> <p>Tip: Use 0.3\u20130.5s for user input, 1\u20132s for heavy computation. Don't abuse long delays in critical flows.</p>"},{"location":"getting-started/decorators/#3-limit-frequency-reactive_throttleinterval","title":"3. Limit frequency: <code>@reactive_throttle(interval)</code>","text":"<p>When to use it: Scroll, resize, high-frequency events. You want to execute at most once per interval.</p> <p>Example:</p> Python<pre><code>from fletx.decorators import reactive_throttle\n\n@reactive_throttle(0.1)  # max once per 100ms\ndef on_scroll_event(e):\n    print(\"Updating visible items...\")\n    # recalc visible range\n</code></pre> <p>Tip: Throttle maintains responsiveness (fast execution), whereas debounce waits for inactivity.</p>"},{"location":"getting-started/decorators/#4-execute-only-if-reactive_whencondition","title":"4. Execute only if: <code>@reactive_when(condition)</code>","text":"<p>When to use it: A flag enables/disables behavior. Feature flags, admin mode, permissions.</p> <p>Example:</p> Python<pre><code>from fletx.decorators import reactive_when\nfrom fletx.core.state import RxBool\n\nis_logged_in = RxBool(False)\n\n@reactive_when(is_logged_in)\ndef sync_user_data():\n    print(\"Syncing...\")\n    # network call\n</code></pre> <p>Tip: The condition can be a callable or a <code>Reactive[bool]</code>.</p>"},{"location":"getting-started/decorators/#5-observe-selectively-reactive_selectreactive_props","title":"5. Observe selectively: <code>@reactive_select(*reactive_props)</code>","text":"<p>When to use it: An object has many properties. You only want to react to certain ones.</p> <p>Example:</p> Python<pre><code>from fletx.decorators import reactive_select\nfrom fletx.core.state import RxStr, RxInt\n\nuser_name = RxStr(\"Alice\")\nuser_age = RxInt(25)\n\n@reactive_select(user_name)  # observe only user_name\ndef display_name():\n    print(f\"Name: {user_name.value}\")\n\nuser_age.value = 26  # no recalc\nuser_name.value = \"Bob\"  # recalc!\n</code></pre> <p>Tip: Reduces unnecessary recomputations when a state has many properties.</p>"},{"location":"getting-started/decorators/#6-pure-derivations-reactive_computeddepsnone","title":"6. Pure derivations: <code>@reactive_computed(deps=None)</code>","text":"<p>When to use it: Create a reactive value computed from other reactives.</p> <p>Example:</p> Python<pre><code>from fletx.decorators import reactive_computed\nfrom fletx.core.state import RxInt\n\nwidth = RxInt(100)\nheight = RxInt(50)\n\n@reactive_computed([width, height])\ndef area():\n    return width.value * height.value\n\nprint(area.value)  # 5000 \u2192 Computed[int]\n</code></pre> <p>Tip: The function must be pure (no side effects). FletX automatically caches the result as long as dependencies don't change.</p>"},{"location":"getting-started/decorators/#7-cache-computations-reactive_memomaxsize64-key_fnnone","title":"7. Cache computations: <code>@reactive_memo(maxsize=64, key_fn=None)</code>","text":"<p>When to use it: An expensive function called multiple times with the same arguments.</p> <p>Example:</p> Python<pre><code>from fletx.decorators import reactive_memo\nfrom fletx.core.state import RxList\n\nusers = RxList([...])\n\n@reactive_memo(maxsize=32)\ndef filter_active_users():\n    # FletX automatically detects that you read `users`\n    return [u for u in users.value if u.active]\n\n# Call 1: compute and cache\nresult1 = filter_active_users()\n# Call 2: return from cache (users unchanged)\nresult2 = filter_active_users()\n# users changes \u2192 cache invalidated\nusers.append(new_user)\n# Call 3: recompute\nresult3 = filter_active_users()\n</code></pre> <p>Tip: Provide <code>key_fn</code> if your arguments are complex.</p>"},{"location":"getting-started/decorators/#8-run-side-effects-reactive_effectdepsnone-auto_runtrue-and-use_effecteffect_fn-deps","title":"8. Run side effects: <code>@reactive_effect(deps=None, auto_run=True)</code> and <code>use_effect(effect_fn, deps)</code>","text":"<p>When to use it: Timers, sockets, subscriptions, DOM modifications, non-GET API calls.</p> <p>Example 1 \u2014 <code>reactive_effect</code> declarative:</p> Python<pre><code>from fletx.decorators import reactive_effect\nfrom fletx.core.state import RxInt\n\ncounter = RxInt(0)\n\n@reactive_effect([counter])\ndef log_changes():\n    print(f\"Counter is now: {counter.value}\")\n\ncounter.value = 1  # \u2192 prints \"Counter is now: 1\"\n\n# To stop observing:\n# log_changes.dispose()\n</code></pre> <p>Example 2 \u2014 <code>use_effect</code> in a builder:</p> Python<pre><code>from fletx.decorators.effects import use_effect\n\ndef my_builder():\n    def setup_timer():\n        timer = asyncio.create_task(do_something())\n\n        def cleanup():\n            timer.cancel()  # critical cleanup!\n\n        return cleanup\n\n    use_effect(setup_timer, [some_dependency])\n    return ft.Text(\"Timer running\")\n</code></pre> <p>Tip: Always return a cleanup function if you open external resources (timers, sockets, subscriptions). FletX calls it when the component is destroyed.</p>"},{"location":"getting-started/decorators/#9-reactive-builder-obx-from-fletxdecoratorswidgetspy","title":"9. Reactive builder: <code>@obx</code> (from <code>fletx/decorators/widgets.py</code>)","text":"<p>When to use it: Create a widget that rebuilds reactively when its dependencies change \u2014 but preserves widget identity in the tree.</p> <p>Example:</p> Python<pre><code>from fletx.decorators.widgets import obx\nfrom fletx.core.state import RxInt\nimport flet as ft\n\nclass CounterController:\n    def __init__(self):\n        self.count = RxInt(0)\n\n    @obx\n    def counter_display(self):\n        # Whenever self.count changes, this builder runs\n        # and the Text is regenerated in place\n        color = 'red' if self.count.value % 2 == 0 else 'blue'\n        return ft.Text(\n            value=f\"Count: {self.count.value}\",\n            color=color\n        )\n</code></pre> <p>Tip: FletX automatically detects all reads of <code>Reactive</code> during the build. No need to list dependencies.</p>"},{"location":"getting-started/decorators/#10-reusable-reactive-controls","title":"10. Reusable reactive controls","text":""},{"location":"getting-started/decorators/#101-bind-a-property-reactive_control-simple_reactive-two_way_reactive","title":"10.1. Bind a property: <code>@reactive_control()</code>, <code>@simple_reactive()</code>, <code>@two_way_reactive()</code>","text":"<p>When to use it: You're creating a reusable widget and want its properties to sync with reactives.</p> <p>Example \u2014 simple binding:</p> Python<pre><code>from fletx.decorators.widgets import simple_reactive\nfrom fletx.core.state import RxStr\n\n@simple_reactive({'value': 'rx_text'})\nclass MyTextField(ft.TextField):\n    def __init__(self):\n        self.rx_text = RxStr(\"Hello\")\n        super().__init__()\n\n# Use it:\ntf = MyTextField()\n# tf.value is now bound to tf.rx_text\ntf.rx_text.value = \"World\"  # \u2192 tf.value changes automatically\n</code></pre> <p>Example \u2014 two-way binding:</p> Python<pre><code>from fletx.decorators.widgets import two_way_reactive\n\n@two_way_reactive({'value': 'rx_text'})\nclass MyTextField(ft.TextField):\n    def __init__(self):\n        self.rx_text = RxStr(\"\")\n        super().__init__()\n\n# User types in the field \u2192 rx_text changes too\n</code></pre>"},{"location":"getting-started/decorators/#102-computed-properties-computed_reactive","title":"10.2. Computed properties: <code>@computed_reactive()</code>","text":"<p>Example:</p> Python<pre><code>from fletx.decorators.widgets import computed_reactive\nfrom fletx.core.state import RxInt\n\n@computed_reactive(\n    text=lambda self: f\"Score: {self.rx_score.value}\",\n    color=lambda self: 'green' if self.rx_score.value &gt; 50 else 'red'\n)\nclass ScoreLabel(ft.Text):\n    def __init__(self):\n        self.rx_score = RxInt(0)\n        super().__init__()\n</code></pre>"},{"location":"getting-started/decorators/#103-reactive-lists-reactive_list","title":"10.3. Reactive lists: <code>@reactive_list()</code>","text":"<p>When to use it: You have an <code>RxList</code> and want it to render automatically.</p> <p>Example:</p> Python<pre><code>from fletx.decorators.widgets import reactive_list\nfrom fletx.core.state import RxList\nimport flet as ft\n\n@reactive_list(\n    items_attr='rx_todos',\n    item_builder=lambda todo, idx: ft.ListTile(\n        title=ft.Text(todo),\n        leading=ft.Text(str(idx))\n    ),\n    empty_builder=lambda: ft.Text(\"No todos yet\")\n)\nclass TodoList(ft.Column):\n    def __init__(self):\n        self.rx_todos = RxList(['Buy milk', 'Walk dog'])\n        super().__init__()\n</code></pre>"},{"location":"getting-started/decorators/#104-forms-reactive_form","title":"10.4. Forms: <code>@reactive_form()</code>","text":"<p>When to use it: You're building a form with validations and a submit handler.</p> <p>Example:</p> Python<pre><code>from fletx.decorators.widgets import reactive_form\nfrom fletx.core.state import RxStr\n\n@reactive_form(\n    form_fields={\n        'email': 'rx_email',\n        'password': 'rx_password'\n    },\n    validation_rules={\n        'email': lambda v: '@' in v,\n        'password': lambda v: len(v) &gt;= 8\n    },\n    on_submit=lambda form: print(\"Form values:\", form.get_values())\n)\nclass LoginForm(ft.Column):\n    def __init__(self):\n        self.rx_email = RxStr(\"\")\n        self.rx_password = RxStr(\"\")\n        super().__init__()\n</code></pre>"},{"location":"getting-started/decorators/#105-state-machine-reactive_state_machine","title":"10.5. State machine: <code>@reactive_state_machine()</code>","text":"<p>When to use it: A widget has multiple states (idle, loading, error, success) and transitions between them.</p> <p>Example:</p> Python<pre><code>from enum import Enum\nfrom fletx.decorators.widgets import reactive_state_machine\nimport flet as ft\n\nclass LoadState(Enum):\n    IDLE = 'idle'\n    LOADING = 'loading'\n    SUCCESS = 'success'\n    ERROR = 'error'\n\n@reactive_state_machine(\n    states=LoadState,\n    initial_state=LoadState.IDLE,\n    transitions={\n        (LoadState.IDLE, 'start'): LoadState.LOADING,\n        (LoadState.LOADING, 'done'): LoadState.SUCCESS,\n        (LoadState.LOADING, 'fail'): LoadState.ERROR,\n        (LoadState.ERROR, 'retry'): LoadState.LOADING,\n    }\n)\nclass DataLoader(ft.Container):\n    def __init__(self):\n        super().__init__()\n\n    def fetch_data(self):\n        if self.transition('start'):\n            # do async work...\n            pass\n</code></pre>"},{"location":"getting-started/decorators/#complete-example-search-engine","title":"Complete example: search engine","text":"Python<pre><code>from fletx.core.state import RxStr, RxList\nfrom fletx.decorators import reactive_debounce, reactive_memo\nfrom fletx.decorators.widgets import obx, reactive_list\nimport flet as ft\n\nclass SearchApp:\n    def __init__(self):\n        self.query = RxStr(\"\")\n        self.results = RxList([])\n        self.all_items = [\"Apple\", \"Apricot\", \"Banana\", \"Blueberry\"]\n\n    @reactive_memo(maxsize=32)\n    def compute_results(self, q: str):\n        # Cache: if q hasn't changed, return from cache\n        return [item for item in self.all_items if item.lower().startswith(q.lower())]\n\n    @reactive_debounce(0.35)\n    def search(self, q: RxStr):\n        # Executes only 350ms after query stops changing\n        self.results.value = self.compute_results(q.value)\n\n    @obx\n    def search_box(self):\n        # Rebuilds if self.query changes\n        return ft.TextField(\n            label=\"Search\",\n            on_change=lambda e: self.query.set(e.control.value)\n        )\n\n    @obx\n    def result_list(self):\n        # Rebuilds if self.results changes\n        return ft.Column([\n            ft.Text(item) for item in self.results.value\n        ])\n\n# Usage:\napp = SearchApp()\n# When query changes \u2192 search() is called after 350ms \u2192 results updates \u2192 result_list() rebuilds\n</code></pre>"},{"location":"getting-started/decorators/#best-practices-summary","title":"Best practices (summary)","text":"Problem Solution Too many updates <code>@reactive_batch()</code> or group mutations User search + API calls <code>@reactive_debounce()</code> Scroll/resize high frequency <code>@reactive_throttle()</code> Function called often with same arg <code>@reactive_memo()</code> Complex condition for execution <code>@reactive_when()</code> Pure derived value <code>@reactive_computed()</code> Effects (timers, sockets) <code>@reactive_effect()</code> or <code>use_effect()</code> Widget that reacts to changes <code>@obx</code> Reusable control <code>@reactive_control</code>, <code>@reactive_form</code>, <code>@reactive_list</code>"},{"location":"getting-started/decorators/#common-pitfalls","title":"Common pitfalls","text":"<ol> <li>Not cleaning up effects \u2192 memory leaks. Always return a cleanup function.</li> <li>Keeping cache too long \u2192 stale data. Prefer small <code>maxsize</code>.</li> <li>Too aggressive debounce \u2192 user waits. Stay under 500ms.</li> <li>Forgetting that <code>computed</code> auto-caches \u2192 no need for memo if you use <code>Computed</code>.</li> <li>Mixing computation and effects \u2192 hard to test. Keep them separate.</li> </ol>"},{"location":"getting-started/decorators/#references","title":"References","text":"<ul> <li><code>fletx/decorators/reactive.py</code> \u2014 batch, memo, debounce, throttle, when, select, effect, computed</li> <li><code>fletx/decorators/effects.py</code> \u2014 use_effect</li> <li><code>fletx/decorators/widgets.py</code> \u2014 obx, reactive_control, reactive_form, reactive_list, reactive_state_machine</li> </ul> <p>See also:</p> <ul> <li>Controllers \u2014 how to structure your reactive logic</li> <li>State Management \u2014 understand <code>RxInt</code>, <code>RxList</code>, <code>Computed</code></li> <li>Pages \u2014 integrate decorators and pages into your app</li> </ul> <p>Ready to try? Start with <code>@reactive_debounce()</code> on a search box. It's the most common use case!</p>"},{"location":"getting-started/dependency-injection/","title":"Dependency Injection","text":"<p>TL;DR: Dependency Injection (DI) is a way to share instances of services across your app without passing them through function parameters. FletX provides a simple container where you register services once and retrieve them anywhere using <code>FletX.put()</code> and <code>FletX.find()</code>.</p>"},{"location":"getting-started/dependency-injection/#what-is-dependency-injection","title":"What is Dependency Injection?","text":"<p>Dependency Injection is a design pattern that solves a common problem: How do I share data between different parts of my app without global variables?</p>"},{"location":"getting-started/dependency-injection/#the-problem-without-di","title":"The Problem Without DI","text":"<p>Imagine you have a service that manages user authentication:</p> Python<pre><code>class AuthService:\n    def __init__(self):\n        self.user = None\n\n    def login(self, username):\n        self.user = username\n\n    def is_logged_in(self):\n        return self.user is not None\n</code></pre> <p>Without DI, you'd have to create this service and pass it everywhere:</p> Python<pre><code># You have to create it once\nauth_service = AuthService()\n\n# Then pass it to every page and controller that needs it\nclass HomePage(FletXPage):\n    def __init__(self, auth_service):  # Passed as parameter\n        self.auth_service = auth_service\n\n    def build(self):\n        return ft.Text(\"Home Page\")\n\nclass ProfilePage(FletXPage):\n    def __init__(self, auth_service):  # Passed as parameter\n        self.auth_service = auth_service\n\n    def build(self):\n        return ft.Text(\"Profile Page\")\n\n# When creating pages, you have to pass it manually\nhome_page = HomePage(auth_service)\nprofile_page = ProfilePage(auth_service)\n</code></pre> <p>This gets tedious quickly, especially with many services and pages.</p>"},{"location":"getting-started/dependency-injection/#the-di-solution","title":"The DI Solution","text":"<p>With Dependency Injection, you register your service once in a central container, and any part of your app can retrieve it:</p> Python<pre><code>from fletx import FletX\n\n# Register once at app startup\nFletX.put(AuthService())\n\n# Retrieve anywhere you need it\nclass HomePage(FletXPage):\n    def build(self):\n        # Just grab it from the container\n        auth = FletX.find(AuthService)\n        return ft.Text(f\"Welcome {auth.user}\")\n\nclass ProfilePage(FletXPage):\n    def build(self):\n        # Same service instance, no parameters needed\n        auth = FletX.find(AuthService)\n        return ft.Text(f\"Profile for {auth.user}\")\n</code></pre> <p>Key benefits: - No parameter passing chains - Services are created once (singleton pattern) - Any page or controller can access them - Easier to test and maintain</p>"},{"location":"getting-started/dependency-injection/#your-first-service","title":"Your First Service","text":"<p>Let's create a simple service and register it:</p>"},{"location":"getting-started/dependency-injection/#step-1-create-the-service","title":"Step 1: Create the Service","text":"Python<pre><code>class CounterService:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1\n\n    def get_count(self):\n        return self.count\n</code></pre>"},{"location":"getting-started/dependency-injection/#step-2-register-at-startup","title":"Step 2: Register at Startup","text":"<p>Register the service when your app starts (usually in <code>main.py</code>):</p> Python<pre><code>from fletx import FletX, FletXApp\nfrom services.counter_service import CounterService\n\n# Register the service in the DI container\nFletX.put(CounterService())\n\n# Now run your app\napp = FletXApp()\napp.run()\n</code></pre>"},{"location":"getting-started/dependency-injection/#step-3-use-the-service-anywhere","title":"Step 3: Use the Service Anywhere","text":"<p>Now any page or controller can retrieve and use the service:</p> Python<pre><code>import flet as ft\nfrom fletx.core import FletXPage\nfrom fletx import FletX\nfrom services.counter_service import CounterService\n\nclass CounterPage(FletXPage):\n    def build(self):\n        # Get the service from the DI container\n        counter_service = FletX.find(CounterService)\n\n        def on_increment(_):\n            counter_service.increment()\n            # In a real app, you'd trigger a page rebuild here\n            # This is simplified for demonstration\n\n        return ft.Column([\n            ft.Text(f\"Count: {counter_service.get_count()}\"),\n            ft.ElevatedButton(\"Increment\", on_click=on_increment)\n        ])\n</code></pre>"},{"location":"getting-started/dependency-injection/#managing-multiple-services","title":"Managing Multiple Services","text":"<p>As your app grows, you'll have many services: authentication, database, settings, notifications, etc.</p>"},{"location":"getting-started/dependency-injection/#organizing-your-services","title":"Organizing Your Services","text":"<p>Create a separate file to register all your services:</p> Python<pre><code># services/__init__.py\nfrom fletx import FletX\nfrom .auth_service import AuthService\nfrom .counter_service import CounterService\nfrom .settings_service import SettingsService\n\ndef register_services():\n    \"\"\"Register all app services in the DI container\"\"\"\n    FletX.put(AuthService())\n    FletX.put(CounterService())\n    FletX.put(SettingsService())\n</code></pre> <p>Then call it from your main app:</p> Python<pre><code># main.py\nfrom fletx import FletXApp\nfrom services import register_services\n\n# Register all services\nregister_services()\n\n# Run the app\napp = FletXApp()\napp.run()\n</code></pre>"},{"location":"getting-started/dependency-injection/#accessing-services-in-different-contexts","title":"Accessing Services in Different Contexts","text":"<p>In Pages:</p> Python<pre><code>class SettingsPage(FletXPage):\n    def build(self):\n        settings = FletX.find(SettingsService)\n        auth = FletX.find(AuthService)\n\n        return ft.Column([\n            ft.Text(f\"Theme: {settings.theme}\"),\n            ft.Text(f\"User: {auth.user}\")\n        ])\n</code></pre> <p>In Controllers:</p> Python<pre><code>from fletx.core import FletXController\nfrom fletx import FletX\n\nclass ProductController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.auth = FletX.find(AuthService)\n        self.db = FletX.find(DatabaseService)\n\n    def get_user_products(self):\n        return self.db.get_products(self.auth.user)\n</code></pre> <p>In Services (Services can depend on other services):</p> Python<pre><code>class OrderService:\n    def __init__(self):\n        # Get dependencies from the container\n        self.auth = FletX.find(AuthService)\n        self.db = FletX.find(DatabaseService)\n        self.payment = FletX.find(PaymentService)\n\n    def create_order(self, product_id, quantity):\n        user = self.auth.user\n        # Use injected dependencies...\n        self.db.save_order(user, product_id, quantity)\n</code></pre>"},{"location":"getting-started/dependency-injection/#advanced-using-tags-for-multiple-instances","title":"Advanced: Using Tags for Multiple Instances","text":"<p>Sometimes you need multiple instances of the same service with different configurations. Use tags:</p> Python<pre><code># Register multiple instances with different tags\nFletX.put(DatabaseService(host=\"localhost\"), tag=\"local\")\nFletX.put(DatabaseService(host=\"production.com\"), tag=\"production\")\n\n# Retrieve the specific one you need\nlocal_db = FletX.find(DatabaseService, tag=\"local\")\nprod_db = FletX.find(DatabaseService, tag=\"production\")\n</code></pre> <p>Example: Multiple API clients</p> Python<pre><code># Register different API clients\nFletX.put(ApiClient(base_url=\"https://api.example.com\"), tag=\"main\")\nFletX.put(ApiClient(base_url=\"https://backup-api.example.com\"), tag=\"backup\")\n\n# Use the main API\nmain_api = FletX.find(ApiClient, tag=\"main\")\ndata = main_api.fetch(\"/users\")\n\n# Fall back to backup if main is down\nif data is None:\n    backup_api = FletX.find(ApiClient, tag=\"backup\")\n    data = backup_api.fetch(\"/users\")\n</code></pre>"},{"location":"getting-started/dependency-injection/#service-lifecycle-management","title":"Service Lifecycle Management","text":""},{"location":"getting-started/dependency-injection/#creating-fresh-instances-per-request","title":"Creating Fresh Instances Per Request","text":"<p>If you need a new instance each time (not a singleton), create it manually:</p> Python<pre><code># Using singleton from DI\ntemplate_service = FletX.find(TemplateService)\n\n# Creating a fresh instance\nfresh_template = TemplateService()\n</code></pre>"},{"location":"getting-started/dependency-injection/#removing-a-service","title":"Removing a Service","text":"<p>If you need to unregister a service:</p> Python<pre><code>FletX.delete(AuthService)\n\n# Try to find it now\nauth = FletX.find(AuthService)  # Will raise an error\n</code></pre>"},{"location":"getting-started/dependency-injection/#clearing-everything","title":"Clearing Everything","text":"<p>Reset the entire DI container (useful in tests):</p> Python<pre><code>FletX.reset()\n</code></pre>"},{"location":"getting-started/dependency-injection/#real-world-example-e-commerce-app","title":"Real-World Example: E-Commerce App","text":"<p>Here's a complete example showing DI in a realistic app:</p>"},{"location":"getting-started/dependency-injection/#step-1-define-your-services","title":"Step 1: Define Your Services","text":"Python<pre><code># services/auth_service.py\nclass AuthService:\n    def __init__(self):\n        self.user = None\n\n    def login(self, username, password):\n        # In a real app, verify credentials\n        self.user = username\n\n    def logout(self):\n        self.user = None\n\n    def is_logged_in(self):\n        return self.user is not None\n\n# services/cart_service.py\nclass CartService:\n    def __init__(self):\n        self.items = []\n\n    def add_item(self, product_id, quantity):\n        self.items.append({\"id\": product_id, \"qty\": quantity})\n\n    def get_total_items(self):\n        return sum(item[\"qty\"] for item in self.items)\n\n    def clear(self):\n        self.items = []\n\n# services/__init__.py\nfrom fletx import FletX\nfrom .auth_service import AuthService\nfrom .cart_service import CartService\n\ndef register_services():\n    FletX.put(AuthService())\n    FletX.put(CartService())\n</code></pre>"},{"location":"getting-started/dependency-injection/#step-2-use-services-in-pages","title":"Step 2: Use Services in Pages","text":"Python<pre><code>import flet as ft\nfrom fletx.core import FletXPage\nfrom fletx import FletX\nfrom services import AuthService, CartService\n\nclass ProductListPage(FletXPage):\n    def build(self):\n        auth = FletX.find(AuthService)\n        cart = FletX.find(CartService)\n\n        def add_to_cart(product_id):\n            if auth.is_logged_in():\n                cart.add_item(product_id, 1)\n                # Show confirmation...\n            else:\n                # Redirect to login...\n                pass\n\n        return ft.Column([\n            ft.Text(f\"Welcome {auth.user}\" if auth.is_logged_in() else \"Guest\"),\n            ft.ElevatedButton(\n                f\"Add to Cart (Items: {cart.get_total_items()})\",\n                on_click=lambda _: add_to_cart(101)\n            )\n        ])\n\nclass CartPage(FletXPage):\n    def build(self):\n        cart = FletX.find(CartService)\n\n        return ft.Column([\n            ft.Text(f\"Cart Items: {cart.get_total_items()}\"),\n            ft.ElevatedButton(\n                \"Checkout\",\n                on_click=lambda _: self.navigate(\"/checkout\")\n            )\n        ])\n</code></pre>"},{"location":"getting-started/dependency-injection/#step-3-initialize-your-app","title":"Step 3: Initialize Your App","text":"Python<pre><code># main.py\nfrom fletx import FletXApp\nfrom routes import setup_routes\nfrom services import register_services\n\n# Setup services first\nregister_services()\n\n# Setup routes\nsetup_routes()\n\n# Run the app\napp = FletXApp()\napp.run()\n</code></pre>"},{"location":"getting-started/dependency-injection/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/dependency-injection/#1-register-services-before-creating-pages","title":"1. Register Services Before Creating Pages","text":"<p>Always call <code>register_services()</code> before <code>app.run()</code>:</p> Python<pre><code># \u2705 Good\nregister_services()\napp = FletXApp()\napp.run()\n\n# \u274c Avoid - services not registered when pages need them\napp = FletXApp()\napp.run()\nregister_services()\n</code></pre>"},{"location":"getting-started/dependency-injection/#2-use-service-files-for-organization","title":"2. Use Service Files for Organization","text":"Text Only<pre><code>services/\n  __init__.py        # Import and register all services\n  auth_service.py    # Authentication logic\n  cart_service.py    # Shopping cart logic\n  settings_service.py # App settings\n</code></pre>"},{"location":"getting-started/dependency-injection/#3-let-services-handle-business-logic","title":"3. Let Services Handle Business Logic","text":"<p>Services should contain the logic, pages should just display:</p> Python<pre><code># \u2705 Good - Logic in service\nclass UserService:\n    def get_user_full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n\nclass ProfilePage(FletXPage):\n    def build(self):\n        user_service = FletX.find(UserService)\n        return ft.Text(user_service.get_user_full_name())\n\n# \u274c Avoid - Logic in page\nclass ProfilePage(FletXPage):\n    def build(self):\n        user_service = FletX.find(UserService)\n        # Logic here - harder to test and reuse\n        full_name = f\"{user_service.first_name} {user_service.last_name}\"\n        return ft.Text(full_name)\n</code></pre>"},{"location":"getting-started/dependency-injection/#4-dont-abuse-global-state","title":"4. Don't Abuse Global State","text":"<p>Use DI for truly shared services, not everything:</p> Python<pre><code># \u2705 Good - Services for business logic\nFletX.put(AuthService())\nFletX.put(DatabaseService())\nFletX.put(NotificationService())\n\n# \u274c Avoid - Don't put everything in DI\nFletX.put({\"theme_color\": \"blue\"})  # Use page state instead\nFletX.put(current_user_id)  # Put it in AuthService\n</code></pre>"},{"location":"getting-started/dependency-injection/#summary","title":"Summary","text":"Task Code Register a service <code>FletX.put(MyService())</code> Retrieve a service <code>FletX.find(MyService)</code> Register with tag <code>FletX.put(MyService(), tag=\"name\")</code> Retrieve with tag <code>FletX.find(MyService, tag=\"name\")</code> Remove a service <code>FletX.delete(MyService)</code> Clear all services <code>FletX.reset()</code>"},{"location":"getting-started/dependency-injection/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Services for more detailed service patterns</li> <li>Explore Controllers to use DI in controller classes</li> <li>Read about Routing to see DI in action with navigation</li> <li>Check the Architecture guide for app structure</li> </ul>"},{"location":"getting-started/fletx-cli/","title":"FletX CLI Guide","text":""},{"location":"getting-started/fletx-cli/#tldr","title":"TL;DR","text":"<p>The FletX CLI (<code>fletx</code>) automates project scaffolding, component generation, and development workflows:</p> Bash<pre><code>fletx new my_project           # Create a new project\nfletx generate controller Home # Add a controller\nfletx run --web --watch        # Run with hot reload\n</code></pre>"},{"location":"getting-started/fletx-cli/#the-problem-youre-solving","title":"The Problem You're Solving","text":"<p>Managing a FletX project requires:</p> <ol> <li>Scaffolding: Creating the initial project structure with proper folders and configurations</li> <li>Consistency: Generating components (controllers, services, pages) that follow FletX conventions</li> <li>Development: Running your app locally during development with feedback and debugging</li> <li>Testing: Validating your code works as expected</li> </ol> <p>Without the CLI, you'd manually create files, remember folder structures, and write boilerplate code every time. The FletX CLI eliminates this friction.</p>"},{"location":"getting-started/fletx-cli/#the-solution-progressive-commands","title":"The Solution: Progressive Commands","text":"<p>The CLI provides four core commands. Let's explore them from beginner to advanced.</p>"},{"location":"getting-started/fletx-cli/#pattern-1-create-your-first-project","title":"Pattern 1: Create Your First Project","text":"<p>Scenario: You're starting a brand-new FletX application.</p> Bash<pre><code># Basic project creation\nfletx new my_app\n\n# This creates:\n# my_app/\n# \u251c\u2500\u2500 main.py                    # Entry point\n# \u251c\u2500\u2500 pyproject.toml             # Project metadata\n# \u251c\u2500\u2500 requirements.txt           # Dependencies\n# \u2514\u2500\u2500 app/\n#     \u251c\u2500\u2500 __init__.py\n#     \u251c\u2500\u2500 routes.py              # Route definitions\n#     \u251c\u2500\u2500 controllers/           # Business logic\n#     \u251c\u2500\u2500 pages/                 # UI screens\n#     \u251c\u2500\u2500 services/              # Reusable utilities\n#     \u2514\u2500\u2500 ...\n</code></pre> <p>What happens: The CLI uses a template to scaffold your entire project structure, including necessary dependencies and configuration files.</p>"},{"location":"getting-started/fletx-cli/#pattern-2-add-customization-during-creation","title":"Pattern 2: Add Customization During Creation","text":"<p>Scenario: You want to document your project metadata from the start.</p> Bash<pre><code>fletx new my_app \\\n  --author \"Jane Doe\" \\\n  --description \"My awesome FletX app\" \\\n  --version \"0.2.0\" \\\n  --python-version \"3.10\"\n</code></pre> <p>Key options:</p> <ul> <li><code>--author</code>: Set the project author (also reads <code>$USER</code> env variable)</li> <li><code>--description</code>: Project description for <code>pyproject.toml</code></li> <li><code>--version</code>: Initial version number</li> <li><code>--python-version</code>: Minimum Python version required</li> <li><code>--no-install</code>: Skip automatic dependency installation (useful if you customize <code>requirements.txt</code> first)</li> <li><code>--directory</code>: Create project in a specific folder instead of current directory</li> </ul>"},{"location":"getting-started/fletx-cli/#pattern-3-generate-code-components","title":"Pattern 3: Generate Code Components","text":"<p>Scenario: Your project exists, and you need to add a new feature. You don't want to manually create the file structure.</p> Bash<pre><code># Create a new controller\nfletx generate controller ProductList --with-test\n\n# Create a service\nfletx generate service ApiClient\n\n# Create a page\nfletx generate page Settings\n</code></pre> <p>What's generated:</p> Bash<pre><code># For controllers:\n# app/controllers/product_list_controller.py\n\n# For services:\n# app/services/api_client_service.py\n\n# For pages:\n# app/pages/settings_page.py\n</code></pre> <p>Each generated file includes:</p> <ul> <li>Proper imports and class structure</li> <li>Docstrings explaining purpose and usage</li> <li>Lifecycle hooks (if applicable, e.g., for controllers)</li> <li>TypeHints for better IDE support</li> </ul> <p>Advanced: Generate with test file</p> Bash<pre><code>fletx generate service DatabaseService --with-test\n\n# Creates two files:\n# - app/services/database_service.py\n# - tests/services/database_service_test.py\n</code></pre> <p>Supported component types:</p> <ul> <li><code>controller</code>: Contains reactive state and business logic</li> <li><code>service</code>: Reusable utility class (no UI logic)</li> <li><code>page</code>: Full screen with navigation and lifecycle</li> <li><code>component</code>: Reusable UI widget (part of pages)</li> <li><code>middleware</code>: Route interceptor</li> <li><code>guard</code>: Route protection logic</li> </ul>"},{"location":"getting-started/fletx-cli/#pattern-4-run-your-project","title":"Pattern 4: Run Your Project","text":"<p>Scenario 1: Simple local development</p> Bash<pre><code># Run on default localhost:8550\nfletx run\n\n# Or specify a different entry point\nfletx run app/main.py\n</code></pre> <p>Scenario 2: Web development with hot reload</p> Bash<pre><code># Open in browser + watch for file changes\nfletx run --web --watch\n</code></pre> <p>When you save a file, the app automatically reloads\u2014perfect for iterating on UI and logic.</p> <p>Scenario 3: Debug mode with logging</p> Bash<pre><code># Enable verbose output + debug mode\nfletx run --debug --verbose\n</code></pre> <p>This shows internal logs, making it easier to diagnose issues.</p> <p>Scenario 4: Desktop or mobile testing</p> Bash<pre><code># Desktop app (native window)\nfletx run --desktop\n\n# Or open on Android/iOS device (requires device connection)\nfletx run --android\n</code></pre> <p>Scenario 5: Environment-specific configuration</p> Bash<pre><code># Set environment variables for your app\nfletx run --env API_URL=https://api.example.com --env DEBUG=true\n\n# Or use a .env-like file\nfletx run --env-file .env.development\n</code></pre> <p>Your FletX app can read these via <code>os.environ.get()</code>.</p>"},{"location":"getting-started/fletx-cli/#pattern-5-run-tests","title":"Pattern 5: Run Tests","text":"<p>Scenario 1: Quick test verification</p> Bash<pre><code># Run all tests\nfletx test\n</code></pre> <p>Scenario 2: Run specific test file</p> Bash<pre><code>fletx test tests/controllers/test_user_controller.py\n</code></pre> <p>Scenario 3: Run tests matching a keyword</p> Bash<pre><code># Only tests with \"user\" in the name\nfletx test -k \"user\"\n</code></pre> <p>Scenario 4: Generate a coverage report</p> Bash<pre><code># See which lines are covered by tests\nfletx test --coverage\n</code></pre> <p>Scenario 5: Debug test failures interactively</p> Bash<pre><code># Drop into debugger on failure\nfletx test --pdb\n</code></pre>"},{"location":"getting-started/fletx-cli/#real-world-example-build-a-todo-app","title":"Real-World Example: Build a Todo App","text":"<p>Let's build a minimal todo app step-by-step using the CLI:</p>"},{"location":"getting-started/fletx-cli/#step-1-create-the-project","title":"Step 1: Create the project","text":"Bash<pre><code>fletx new todo_app \\\n  --author \"Developer\" \\\n  --description \"A simple todo list app\"\n\ncd todo_app\n</code></pre>"},{"location":"getting-started/fletx-cli/#step-2-generate-core-components","title":"Step 2: Generate core components","text":"Bash<pre><code># Create the main controller for todos\nfletx generate controller TodoList --with-test\n\n# Create a service to handle storage\nfletx generate service TodoStorage --with-test\n\n# Create the main page\nfletx generate page Home\n</code></pre>"},{"location":"getting-started/fletx-cli/#step-3-examine-generated-code","title":"Step 3: Examine generated code","text":"Bash<pre><code># Look at the controller structure\ncat app/controllers/todo_list_controller.py\n\n# Look at the service\ncat app/services/todo_storage_service.py\n\n# Look at the page\ncat app/pages/home_page.py\n</code></pre> <p>Each file has the correct imports and basic structure ready for you to fill in logic.</p>"},{"location":"getting-started/fletx-cli/#step-4-implement-logic-you-edit-the-files","title":"Step 4: Implement logic (you edit the files)","text":"<p>In <code>app/controllers/todo_list_controller.py</code>:</p> Python<pre><code>from fletx.core import FletXController, create_rx_string, create_rx_list\n\nclass TodoListController(FletXController):\n    def __init__(self):\n        self.todos = create_rx_list([])\n        self.input_value = create_rx_string(\"\")\n\n    def add_todo(self, text):\n        self.todos.add({\"id\": len(self.todos), \"text\": text, \"done\": False})\n        self.input_value.set(\"\")\n\n    def toggle_todo(self, todo_id):\n        for todo in self.todos:\n            if todo[\"id\"] == todo_id:\n                todo[\"done\"] = not todo[\"done\"]\n        self.todos.refresh()\n</code></pre>"},{"location":"getting-started/fletx-cli/#step-5-run-with-hot-reload","title":"Step 5: Run with hot reload","text":"Bash<pre><code># Start the app with auto-reload\nfletx run --web --watch\n\n# Browser opens automatically\n# Edit controllers/pages, save, and see changes instantly\n</code></pre>"},{"location":"getting-started/fletx-cli/#step-6-test-your-controller","title":"Step 6: Test your controller","text":"Bash<pre><code># Generate and run tests\nfletx test --coverage\n\n# See which parts of your code are tested\n</code></pre>"},{"location":"getting-started/fletx-cli/#common-cli-workflows","title":"Common CLI Workflows","text":""},{"location":"getting-started/fletx-cli/#workflow-1-rapid-prototyping","title":"Workflow 1: Rapid Prototyping","text":"Bash<pre><code># Start fresh\nfletx new proto --no-install\n\n# Generate pieces quickly\nfletx generate page Dashboard\nfletx generate controller Dashboard\nfletx generate service ApiClient\n\n# Run and iterate\nfletx run --web --watch --debug\n</code></pre>"},{"location":"getting-started/fletx-cli/#workflow-2-team-collaboration","title":"Workflow 2: Team Collaboration","text":"Bash<pre><code># Use shared template (if available)\nfletx new project_name --template team-standard\n\n# Generate consistent components\nfletx generate controller UserAuth --with-test\nfletx generate service UserAuthService --with-test\n\n# Test and commit\nfletx test\ngit add .\ngit commit -m \"Add user auth\"\n</code></pre>"},{"location":"getting-started/fletx-cli/#workflow-3-cicd-integration","title":"Workflow 3: CI/CD Integration","text":"Bash<pre><code># In your CI pipeline:\n\n# Install and test\npip install -r requirements.txt\nfletx test --coverage\n\n# Check compatibility\nfletx check --json\n</code></pre>"},{"location":"getting-started/fletx-cli/#cli-reference-complete-options","title":"CLI Reference: Complete Options","text":""},{"location":"getting-started/fletx-cli/#fletx-new-name","title":"<code>fletx new &lt;name&gt;</code>","text":"Option Type Default Purpose <code>--template</code> string <code>project</code> Choose project template <code>--directory</code> path current dir Where to create the project <code>--author</code> string <code>$USER</code> Project author name <code>--description</code> string Generated Project description <code>--version</code> string <code>0.1.0</code> Initial version <code>--python-version</code> string <code>3.12</code> Min Python version <code>--overwrite</code> flag false Overwrite existing files <code>--no-install</code> flag false Skip dependency installation"},{"location":"getting-started/fletx-cli/#fletx-generate-type-name","title":"<code>fletx generate &lt;type&gt; &lt;name&gt;</code>","text":"Type Purpose Output <code>controller</code> Reactive state + logic <code>app/controllers/&lt;name&gt;_controller.py</code> <code>service</code> Utility class <code>app/services/&lt;name&gt;_service.py</code> <code>page</code> Full screen <code>app/pages/&lt;name&gt;_page.py</code> <code>component</code> Reusable widget <code>app/components/&lt;name&gt;_component.py</code> <code>middleware</code> Route interceptor <code>app/middlewares/&lt;name&gt;_middleware.py</code> <code>guard</code> Route protection <code>app/guards/&lt;name&gt;_guard.py</code> <p>Options:</p> Option Type Purpose <code>--output-dir</code> path Custom output directory <code>--template</code> string Specific template name <code>--overwrite</code> flag Overwrite existing component <code>--with-test</code> flag Generate test file automatically"},{"location":"getting-started/fletx-cli/#fletx-run-target","title":"<code>fletx run [target]</code>","text":"Option Type Default Purpose <code>--host</code> or <code>-h</code> string <code>localhost</code> Bind address <code>--port</code> or <code>-p</code> int <code>8550</code> Port number <code>--debug</code> flag false Enable debug logging <code>--watch</code> or <code>-W</code> flag false Auto-reload on file changes <code>--web</code> or <code>-w</code> flag false Open in browser <code>--desktop</code> or <code>-d</code> flag false Force desktop mode <code>--android</code> or <code>-A</code> flag false Deploy to Android <code>--ios</code> or <code>-X</code> flag false Deploy to iOS <code>--env</code> or <code>-e</code> string - Set env var (<code>KEY=VALUE</code>) <code>--install-deps</code> or <code>-r</code> flag false Install requirements first <code>--verbose</code> or <code>-v</code> flag false Verbose logging"},{"location":"getting-started/fletx-cli/#fletx-test-path","title":"<code>fletx test [path]</code>","text":"Option Type Purpose <code>-k</code> / <code>--keyword</code> string Run tests matching keyword <code>-v</code> / <code>--verbose</code> flag Verbose output <code>--coverage</code> flag Generate coverage report <code>--pdb</code> flag Debug on failure"},{"location":"getting-started/fletx-cli/#best-practices","title":"Best Practices","text":"Practice Why How Use templates for consistency Ensures all projects follow your team's architecture <code>fletx new app --template team-standard</code> Generate with tests Catches bugs early and documents expected behavior <code>fletx generate controller X --with-test</code> Use <code>--watch</code> during development Immediate feedback speeds up iteration <code>fletx run --web --watch</code> Test before committing Prevents broken code in the repository <code>fletx test</code> in git hooks or CI Use <code>--env</code> for sensitive config Avoids hardcoding secrets <code>--env API_KEY=$SECRET_KEY</code> Version your Python requirement Prevents compatibility issues across machines <code>--python-version 3.11</code> in <code>new</code> command"},{"location":"getting-started/fletx-cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/fletx-cli/#project-already-exists","title":"\"Project already exists\"","text":"Bash<pre><code># Use --overwrite to replace\nfletx new my_project --overwrite\n\n# Or specify different directory\nfletx new my_project --directory ./projects/new_app\n</code></pre>"},{"location":"getting-started/fletx-cli/#template-not-found","title":"\"Template not found\"","text":"Bash<pre><code># Check available templates\nfletx --help\n\n# Use explicit template name\nfletx new app --template project\n</code></pre>"},{"location":"getting-started/fletx-cli/#port-8550-already-in-use","title":"\"Port 8550 already in use\"","text":"Bash<pre><code># Run on a different port\nfletx run --port 8551\n</code></pre>"},{"location":"getting-started/fletx-cli/#module-not-found-when-running","title":"\"Module not found when running\"","text":"Bash<pre><code># Install dependencies first\nfletx run --install-deps\n\n# Or manually\npip install -r requirements.txt\n</code></pre>"},{"location":"getting-started/fletx-cli/#tests-dont-run","title":"\"Tests don't run\"","text":"Bash<pre><code># Install test dependencies\npip install pytest pytest-cov\n\n# Then run\nfletx test -v\n</code></pre>"},{"location":"getting-started/fletx-cli/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Generating a component that already exists (overwrites your code)</p> Bash<pre><code># Safe: use --with-test only, don't --overwrite\nfletx generate controller Widget --with-test\n\n# Risky: --overwrite deletes your edits!\n# fletx generate controller Widget --overwrite\n</code></pre> <p>Pitfall 2: Running <code>fletx run</code> from the wrong directory</p> Bash<pre><code># Wrong: run from outside project\n$ cd ~ &amp;&amp; fletx run\n\n# Correct: run from project root\n$ cd my_project &amp;&amp; fletx run\n</code></pre> <p>Pitfall 3: Forgetting <code>--watch</code> during active development</p> Bash<pre><code># Tedious: manually restart after each save\n$ fletx run\n\n# Better: auto-reload on save\n$ fletx run --web --watch\n</code></pre>"},{"location":"getting-started/fletx-cli/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture: Understand how controllers, pages, and services connect</li> <li>Controllers: Learn to build reactive state and business logic</li> <li>Pages: Create screens and handle navigation</li> <li>Services: Build reusable utilities and integrations</li> <li>Dependency Injection: Manage component dependencies elegantly</li> <li>State Management: Use reactive primitives (RxInt, RxList, etc.)</li> <li>Decorators: Control execution timing and memoization</li> </ul>"},{"location":"getting-started/installation/","title":"Introduction","text":"<p>TL;DR: Install FletX with <code>pip install fletxr[dev]</code>, create your first app in 5 minutes with <code>fletx new my_app</code>, run it with <code>fletx run</code>, and you're building! FletX is a framework for building reactive, modular desktop and web apps with Flet.</p>"},{"location":"getting-started/installation/#what-is-fletx","title":"What is FletX?","text":"<p>FletX is a reactive application framework built on top of Flet. It brings modern app architecture patterns (dependency injection, routing, state management, controllers) to Flet applications.</p>"},{"location":"getting-started/installation/#fletx-vs-flet","title":"FletX vs Flet","text":"<p>Flet gives you widgets and basic page routing. You write everything in one place:</p> Python<pre><code># Pure Flet - manual, scattered logic\nimport flet as ft\n\ndef main(page: ft.Page):\n    page.title = \"Counter\"\n\n    counter = {\"value\": 0}  # State scattered everywhere\n\n    def increment(_):\n        counter[\"value\"] += 1\n        text.value = str(counter[\"value\"])\n        page.update()\n\n    text = ft.Text(counter[\"value\"])\n    page.add(text, ft.ElevatedButton(\"Increment\", on_click=increment))\n\nft.app(target=main)\n</code></pre> <p>FletX organizes your app with controllers, routing, DI, and reactive state:</p> Python<pre><code># FletX - organized, reactive, scalable\nfrom fletx import FletXApp, FletXPage, FletXController, RxInt\nfrom fletx.navigation import router_config\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass CounterController(FletXController):\n    def __init__(self):\n        self.count = RxInt(0)\n\nclass CounterPage(FletXPage):\n    ctrl = CounterController()\n\n    @obx\n    def build(self):\n        return ft.Column([\n            ft.Text(f\"Count: {self.ctrl.count}\"),\n            ft.ElevatedButton(\"Increment\", on_click=lambda _: self.ctrl.count.increment())\n        ])\n\nrouter_config.add_route(\"/\", CounterPage)\napp = FletXApp().run()\n</code></pre> <p>Why FletX?</p> <ul> <li>\u2705 Organized structure - no spaghetti code</li> <li>\u2705 Reactive UI - UI updates automatically when state changes</li> <li>\u2705 Scalable - works for small apps and large projects</li> <li>\u2705 Developer experience - CLI, generators, best practices built-in</li> </ul>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing FletX, make sure you have:</p> <ul> <li>Python &gt;=3.10,&lt;=3.13 (download here)</li> <li>A package manager: </li> <li><code>pip</code> (comes with Python)</li> <li><code>uv</code> (recommended, faster): <code>pip install uv</code></li> </ul> <p>Check your Python version:</p> Bash<pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#installation","title":"Installation","text":""},{"location":"getting-started/installation/#step-1-install-fletx","title":"Step 1: Install FletX","text":"Bash<pre><code>pip install fletxr[dev]\n</code></pre> <p>\u2705 This installs both Flet and FletX. The <code>[dev]</code> extras include development tools.</p> <p>\ud83d\udca1 Using <code>uv</code>? Run: <code>uv pip install fletxr[dev]</code></p>"},{"location":"getting-started/installation/#step-2-verify-installation","title":"Step 2: Verify Installation","text":"<p>Test that everything works:</p> Bash<pre><code>fletx --version\n</code></pre> <p>You should see the FletX version number.</p>"},{"location":"getting-started/installation/#creating-your-first-app","title":"Creating Your First App","text":"<p>You have two options: Quick start with CLI (recommended) or manual setup.</p>"},{"location":"getting-started/installation/#option-1-quick-start-with-cli-recommended","title":"Option 1: Quick Start with CLI (Recommended)","text":"<p>The FletX CLI creates a complete project structure for you:</p> Bash<pre><code># Create a new project\nfletx new my_counter_app\n\n# Navigate into it\ncd my_counter_app\n\n# Run it\nfletx run\n</code></pre> <p>That's it! Your app is running. The CLI sets up: - Project structure - Example pages and controllers - Routing configuration - Build configuration</p>          web                   Mobile                   Desktop"},{"location":"getting-started/installation/#option-2-manual-setup","title":"Option 2: Manual Setup","text":"<p>Create a <code>main.py</code> file:</p> Python<pre><code>import flet as ft\nfrom fletx import FletXApp\nfrom fletx.core import FletXPage, FletXController, RxInt\nfrom fletx.navigation import router_config\nfrom fletx.decorators import obx\n\n# Step 1: Create a controller to manage state\nclass CounterController(FletXController):\n    def __init__(self):\n        self.count = RxInt(0)\n\n# Step 2: Create a page that uses the controller\nclass CounterPage(FletXPage):\n    ctrl = CounterController()\n\n    # @obx makes this widget reactive - it rebuilds when count changes\n    @obx\n    def counter_text(self):\n        return ft.Text(\n            value = f'Count: {self.ctrl.count}',\n            size = 50, \n            weight = \"bold\",\n            color = 'red' if not self.ctrl.count.value % 2 == 0 else 'white'\n        )\n\n    def build(self):\n        return ft.Column(\n            controls = [\n                self.counter_text(),\n                ft.ElevatedButton(\n                    \"Increment\",\n                    on_click = lambda e: self.ctrl.count.increment()  # Auto UI update\n                )\n            ]\n        )\n\n# Step 3: Register the route\nrouter_config.add_route(path=\"/\", component=CounterPage)\n\n# Step 4: Create and run the app\nif __name__ == \"__main__\":\n    app = FletXApp(\n        title=\"My First FletX App\",\n        initial_route=\"/\"\n    )\n    app.run()\n</code></pre> <p>Run it:</p> Bash<pre><code>python main.py\n</code></pre> <p>Desktop </p>"},{"location":"getting-started/installation/#understanding-the-app-structure","title":"Understanding the App Structure","text":"<p>When you create an app with <code>fletx new</code>, you get this structure:</p> Text Only<pre><code>my_app/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 controllers/          # Controllers manage state and logic\n\u2502   \u2502   \u2514\u2500\u2500 counter_ctrl.py\n\u2502   \u251c\u2500\u2500 pages/                # UI pages (what users see)\n\u2502   \u2502   \u251c\u2500\u2500 home_page.py\n\u2502   \u2502   \u2514\u2500\u2500 settings_page.py\n\u2502   \u251c\u2500\u2500 services/             # Business logic (API, database, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 auth_service.py\n\u2502   \u251c\u2500\u2500 components/           # Reusable widgets\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 navigation_bar.py\n\u2502   \u251c\u2500\u2500 models/               # Data structures\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 user_model.py\n\u2502   \u2514\u2500\u2500 routes.py             # All routes defined here\n\u251c\u2500\u2500 assets/                   # Images, fonts, static files\n\u2502   \u251c\u2500\u2500 images/\n\u2502   \u2514\u2500\u2500 fonts/\n\u251c\u2500\u2500 tests/                    # Unit and integration tests\n\u251c\u2500\u2500 main.py                   # Application entry point\n\u251c\u2500\u2500 pyproject.toml            # Python dependencies and metadata\n\u251c\u2500\u2500 .python-version           # Python version specification\n\u2514\u2500\u2500 README.md                 # Project documentation\n</code></pre> <p>Key directories:</p> Directory Purpose <code>controllers/</code> Manage app state using reactive variables (<code>RxInt</code>, <code>RxStr</code>, etc.) <code>pages/</code> Define UI pages using <code>FletXPage</code> <code>services/</code> Shared business logic (database, API calls, authentication) <code>components/</code> Reusable UI widgets you build from Flet controls <code>models/</code> Data classes and structures <code>routes.py</code> Define all app routes in one place"},{"location":"getting-started/installation/#your-first-real-app","title":"Your First Real App","text":"<p>Let's create a simple todo app to understand the structure:</p>"},{"location":"getting-started/installation/#step-1-define-the-data-model","title":"Step 1: Define the Data Model","text":"Python<pre><code># app/models/todo.py\nclass Todo:\n    def __init__(self, id: int, title: str, completed: bool = False):\n        self.id = id\n        self.title = title\n        self.completed = completed\n</code></pre>"},{"location":"getting-started/installation/#step-2-create-a-service","title":"Step 2: Create a Service","text":"Python<pre><code># app/services/todo_service.py\nfrom app.models.todo import Todo\n\nclass TodoService:\n    def __init__(self):\n        self.todos = []\n        self.next_id = 1\n\n    def add_todo(self, title: str):\n        todo = Todo(self.next_id, title)\n        self.todos.append(todo)\n        self.next_id += 1\n        return todo\n\n    def get_todos(self):\n        return self.todos\n\n    def toggle_todo(self, todo_id: int):\n        for todo in self.todos:\n            if todo.id == todo_id:\n                todo.completed = not todo.completed\n\n    def delete_todo(self, todo_id: int):\n        self.todos = [t for t in self.todos if t.id != todo_id]\n</code></pre>"},{"location":"getting-started/installation/#step-3-create-a-controller","title":"Step 3: Create a Controller","text":"Python<pre><code># app/controllers/todo_controller.py\nfrom fletx.core import FletXController, RxList\nfrom app.services.todo_service import TodoService\n\nclass TodoController(FletXController):\n    def __init__(self):\n        self.todos = RxList([])\n        self.service = TodoService()\n        super().__init__()\n\n    def add_todo(self, title: str):\n        self.service.add_todo(title)\n        self.update_todos_list()\n\n    def toggle_todo(self, todo_id: int):\n        self.service.toggle_todo(todo_id)\n        self.update_todos_list()\n\n    def delete_todo(self, todo_id: int):\n        self.service.delete_todo(todo_id)\n        self.update_todos_list()\n\n    def update_todos_list(self):\n        self.todos.value = self.service.get_todos()\n</code></pre>"},{"location":"getting-started/installation/#step-4-create-a-page","title":"Step 4: Create a Page","text":"Python<pre><code># app/pages/todo_page.py\nimport flet as ft\nfrom fletx.core import FletXPage\nfrom fletx.decorators import obx\nfrom app.controllers.todo_controller import TodoController\n\nclass TodoPage(FletXPage):\n    ctrl = TodoController()\n\n    def build(self):\n        input_field = ft.TextField(\n            label=\"Add a todo\",\n            width=300\n        )\n\n        def add_todo(_):\n            if input_field.value.strip():\n                self.ctrl.add_todo(input_field.value)\n                input_field.value = \"\"\n                self.update()\n\n        add_button = ft.ElevatedButton(\"Add\", on_click=add_todo)\n\n        @obx\n        def todo_list():\n            return ft.Column([\n                ft.Checkbox(\n                    label=todo.title,\n                    value=todo.completed,\n                    on_change=lambda _: self.ctrl.toggle_todo(todo.id)\n                )\n                for todo in self.ctrl.todos\n            ])\n\n        return ft.Column([\n            ft.Text(\"My Todos\", size=32, weight=\"bold\"),\n            ft.Row([input_field, add_button]),\n            todo_list()\n        ])\n</code></pre>"},{"location":"getting-started/installation/#step-5-register-the-route","title":"Step 5: Register the Route","text":"Python<pre><code># app/routes.py\nfrom fletx.navigation import router_config\nfrom app.pages.todo_page import TodoPage\n\ndef setup_routes():\n    router_config.add_route(\n        path=\"/\",\n        component=TodoPage\n    )\n</code></pre>"},{"location":"getting-started/installation/#step-6-run-the-app","title":"Step 6: Run the App","text":"Python<pre><code># main.py\nfrom fletx import FletXApp\nfrom app.routes import setup_routes\n\nif __name__ == \"__main__\":\n    setup_routes()\n\n    app = FletXApp(\n        title=\"My Todo App\",\n        initial_route=\"/\"\n    )\n    app.run()\n</code></pre>"},{"location":"getting-started/installation/#using-the-fletx-cli","title":"Using the FletX CLI","text":"<p>The CLI helps you generate code and manage your project:</p> Bash<pre><code># Create a new project\nfletx new my_app --author \"Your Name\" --description \"My awesome app\"\n\n# Generate a new page\nfletx generate page products_page\n\n# Generate a new controller\nfletx generate controller products_controller --with-test\n\n# Run with hot reload (in development)\nfletx run --debug\n\n# Build for web\nfletx run --web\n\n# Run tests\nfletx test\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have FletX installed and your first app running:</p> <ol> <li>Learn about Routing - Navigate between pages</li> <li>Understand Dependency Injection - Share services across your app</li> <li>Explore State Management with Controllers - Manage app state reactively</li> <li>Check Services - Organize business logic</li> <li>Read Architecture - See the big picture</li> </ol>"},{"location":"getting-started/pages/","title":"Pages","text":"<p>TL;DR: A <code>FletXPage</code> is a complete screen component with structured lifecycle (<code>on_init()</code>, <code>on_destroy()</code>), a <code>build()</code> method for UI, automatic controller management, event handling (keyboard, gestures, window events), and built-in support for app bars, drawers, floating action buttons, and keyboard shortcuts.</p>"},{"location":"getting-started/pages/#what-is-a-fletxpage","title":"What is a FletXPage?","text":"<p>A <code>FletXPage</code> represents a single screen or view in your FletX application. It's much more than Flet's basic page - it's a fully-featured component system that includes:</p> <ul> <li>Lifecycle management - Structured stages from initialization to disposal</li> <li>Built-in event handling - Keyboard, gestures, window resize, media changes</li> <li>Navigation elements - App bars, drawers, FABs, bottom sheets</li> <li>Controller integration - Seamless connection to business logic</li> <li>Reactive updates - Automatic UI refresh on state changes</li> <li>Keyboard shortcuts - Power-user features</li> <li>Performance monitoring - Track render times and statistics</li> <li>Resource cleanup - Automatic disposal of effects and subscriptions</li> </ul>"},{"location":"getting-started/pages/#why-fletxpage","title":"Why FletXPage?","text":"<p>Plain Flet - Manual and Scattered:</p> Python<pre><code>import flet as ft\n\ndef main(page: ft.Page):\n    page.title = \"Todo\"\n    todos = []  # State scattered\n\n    def add_todo(e):\n        todos.append(input_field.value)\n        # Manual UI update\n        list_view.controls.clear()\n        for todo in todos:\n            list_view.controls.append(ft.Text(todo))\n        page.update()\n\n    input_field = ft.TextField()\n    list_view = ft.Column()\n    page.add(input_field, ft.ElevatedButton(\"Add\", on_click=add_todo), list_view)\n    # No cleanup, no structure\n\nft.app(target=main)\n</code></pre> <p>FletX - Organized and Reactive:</p> Python<pre><code>from fletx.core import FletXPage, FletXController\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass TodoController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.todos = self.create_rx_list([])\n\n    def add_todo(self, title: str):\n        self.todos.append(title)\n        self.emit_local(\"todo_added\", title)\n\nclass TodoPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = TodoController()\n\n    def on_init(self):\n        # Called when page appears\n        self.controller.on_local(\"todo_added\", self._on_todo_added)\n\n    def _on_todo_added(self, event):\n        self.refresh()\n\n    def build(self):\n        return ft.Column([\n            ft.TextField(label=\"Add todo\"),\n            ft.Column([\n                ft.Text(todo) for todo in self.controller.todos\n            ])\n        ])\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Clear structure and organization</li> <li>\u2705 Automatic state and UI synchronization</li> <li>\u2705 Proper lifecycle and resource cleanup</li> <li>\u2705 Event-driven architecture</li> </ul>"},{"location":"getting-started/pages/#page-lifecycle","title":"Page Lifecycle","text":"<p>FletX pages go through distinct stages:</p> Text Only<pre><code>INITIALIZING \u2192 MOUNTED \u2192 ACTIVE \u2192 UNMOUNTING \u2192 DISPOSED\n</code></pre>"},{"location":"getting-started/pages/#lifecycle-states","title":"Lifecycle States","text":"State When What You Can Do <code>INITIALIZING</code> Page created in <code>__init__()</code> Initialize controller, setup state <code>MOUNTED</code> Page attached to view <code>on_init()</code> called - load data <code>ACTIVE</code> Page fully visible Respond to user input <code>UNMOUNTING</code> Before removal <code>on_destroy()</code> called - cleanup <code>DISPOSED</code> After removal Resources freed"},{"location":"getting-started/pages/#lifecycle-hooks","title":"Lifecycle Hooks","text":"Python<pre><code>class MyPage(FletXPage):\n    def on_init(self):\n        \"\"\"Called when page becomes visible\"\"\"\n        print(\"Page appeared!\")\n        # Load data\n        self.controller.load_data()\n        # Setup listeners\n        self.controller.on_local(\"data_loaded\", self._on_data_ready)\n\n    def on_destroy(self):\n        \"\"\"Called when page will be removed\"\"\"\n        print(\"Page will disappear!\")\n        # Cancel requests\n        self.controller.cancel_pending()\n        # Close connections\n        if hasattr(self, 'websocket'):\n            self.websocket.close()\n</code></pre>"},{"location":"getting-started/pages/#your-first-fletxpage","title":"Your First FletXPage","text":""},{"location":"getting-started/pages/#step-1-create-a-simple-page","title":"Step 1: Create a Simple Page","text":"Python<pre><code>import flet as ft\nfrom fletx.core import FletXPage\n\nclass HelloPage(FletXPage):\n    def build(self):\n        return ft.Column([\n            ft.Text(\"Hello FletX!\", size=32),\n            ft.ElevatedButton(\"Click Me\")\n        ])\n</code></pre>"},{"location":"getting-started/pages/#step-2-register-and-run","title":"Step 2: Register and Run","text":"Python<pre><code>from fletx import FletXApp\nfrom fletx.navigation import router_config\n\nrouter_config.add_route(\"/\", HelloPage)\napp = FletXApp()\napp.run()\n</code></pre> <p>Done! \ud83c\udf89</p>"},{"location":"getting-started/pages/#building-ui-with-build","title":"Building UI with <code>build()</code>","text":"<p>The <code>build()</code> method returns your page's UI. Key principles:</p> <ul> <li>Pure - No side effects</li> <li>Fast - Should render quickly</li> <li>Declarative - Describe what UI to show</li> </ul>"},{"location":"getting-started/pages/#basic-layout","title":"Basic Layout","text":"Python<pre><code>def build(self):\n    return ft.Column([\n        ft.Text(\"Title\"),\n        ft.TextField(label=\"Input\"),\n        ft.ElevatedButton(\"Submit\")\n    ])\n</code></pre>"},{"location":"getting-started/pages/#reactive-ui-with-obx","title":"Reactive UI with <code>@obx</code>","text":"Python<pre><code>from fletx.decorators import obx\n\nclass CounterPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = CounterController()\n\n    @obx\n    def counter_display(self):\n        \"\"\"Rebuilds automatically when count changes\"\"\"\n        return ft.Text(\n            f\"Count: {self.controller.count}\",\n            size=24,\n            weight=\"bold\"\n        )\n\n    def build(self):\n        return ft.Column([\n            self.counter_display(),\n            ft.Row([\n                ft.ElevatedButton(\n                    \"Increment\",\n                    on_click=lambda _: self.controller.count.increment()\n                ),\n                ft.ElevatedButton(\n                    \"Decrement\",\n                    on_click=lambda _: self.controller.count.decrement()\n                )\n            ])\n        ])\n</code></pre>"},{"location":"getting-started/pages/#complex-layouts","title":"Complex Layouts","text":"Python<pre><code>def build(self):\n    return ft.Column([\n        # Header\n        ft.Container(\n            content=ft.Text(\"Dashboard\", size=28, weight=\"bold\"),\n            padding=20,\n            bgcolor=ft.colors.BLUE\n        ),\n        # Content\n        ft.Container(\n            content=ft.Row([\n                # Sidebar\n                ft.Container(\n                    content=ft.Column([\n                        ft.Text(\"Menu\"),\n                        ft.TextButton(\"Home\"),\n                        ft.TextButton(\"Settings\")\n                    ]),\n                    width=200,\n                    bgcolor=ft.colors.SURFACE\n                ),\n                # Main content\n                ft.Container(\n                    content=ft.Text(\"Main content here\"),\n                    expand=True\n                )\n            ]),\n            expand=True\n        )\n    ])\n</code></pre>"},{"location":"getting-started/pages/#working-with-controllers","title":"Working with Controllers","text":"<p>Controllers contain your business logic. Here's how to use them correctly:</p>"},{"location":"getting-started/pages/#create-a-controller","title":"Create a Controller","text":"Python<pre><code>from fletx.core import FletXController\n\nclass UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        # Create reactive variables using create_rx_* methods\n        self.username = self.create_rx_str(\"\")\n        self.email = self.create_rx_str(\"\")\n        self.is_loading = self.create_rx_bool(False)\n        self.users = self.create_rx_list([])\n        self.error = self.create_rx_str(\"\")\n\n    def load_users(self):\n        \"\"\"Load users from API\"\"\"\n        self.set_loading(True)\n        self.clear_error()\n\n        try:\n            # Fetch data\n            users_data = self._fetch_users()\n            self.users.value = users_data\n\n            # Emit event\n            self.emit_local(\"users_loaded\", len(users_data))\n        except Exception as e:\n            self.set_error(str(e))\n            self.emit_local(\"error\", str(e))\n        finally:\n            self.set_loading(False)\n\n    def add_user(self, username: str, email: str):\n        \"\"\"Add a new user\"\"\"\n        user = {\"name\": username, \"email\": email}\n        self.users.append(user)\n        self.emit_local(\"user_added\", user)\n\n    def _fetch_users(self):\n        # Simulate API call\n        return [\n            {\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            {\"name\": \"Bob\", \"email\": \"bob@example.com\"}\n        ]\n</code></pre>"},{"location":"getting-started/pages/#use-controller-in-page","title":"Use Controller in Page","text":"Python<pre><code>class UsersPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        # Create controller\n        self.controller = UserController()\n\n    def on_init(self):\n        \"\"\"When page appears\"\"\"\n        # Load data\n        self.controller.load_users()\n\n        # Listen to events\n        self.controller.on_local(\"users_loaded\", self._on_users_loaded)\n        self.controller.on_local(\"user_added\", self._on_user_added)\n        self.controller.on_local(\"error\", self._on_error)\n\n    def _on_users_loaded(self, event):\n        print(f\"Loaded {event.data} users\")\n        self.refresh()\n\n    def _on_user_added(self, event):\n        print(f\"Added user: {event.data}\")\n        self.refresh()\n\n    def _on_error(self, event):\n        print(f\"Error: {event.data}\")\n        self.refresh()\n\n    @obx\n    def build(self):\n        # Show loader while loading\n        if self.controller.is_loading:\n            return ft.Center(\n                content=ft.Column([\n                    ft.ProgressRing(),\n                    ft.Text(\"Loading...\")\n                ])\n            )\n\n        # Show error if present\n        if self.controller.error:\n            return ft.Center(\n                content=ft.Column([\n                    ft.Icon(ft.icons.ERROR, color=ft.colors.RED),\n                    ft.Text(f\"Error: {self.controller.error}\")\n                ])\n            )\n\n        # Show users\n        return ft.Column([\n            ft.Text(f\"Users ({len(self.controller.users)})\", size=24),\n            ft.Column([\n                ft.ListTile(\n                    title=ft.Text(user[\"name\"]),\n                    subtitle=ft.Text(user[\"email\"])\n                )\n                for user in self.controller.users\n            ])\n        ])\n</code></pre>"},{"location":"getting-started/pages/#navigation-elements","title":"Navigation Elements","text":""},{"location":"getting-started/pages/#app-bar","title":"App Bar","text":"Python<pre><code>class SettingsPage(FletXPage):\n    def build_app_bar(self):\n        \"\"\"Override to create app bar\"\"\"\n        return ft.AppBar(\n            title=ft.Text(\"Settings\"),\n            center_title=True,\n            actions=[\n                ft.IconButton(ft.icons.HELP_OUTLINE),\n                ft.PopupMenuButton([\n                    ft.PopupMenuItem(text=\"Option 1\"),\n                    ft.PopupMenuItem(text=\"Option 2\")\n                ])\n            ]\n        )\n\n    def build(self):\n        return ft.Column([\n            ft.Text(\"Settings content\")\n        ])\n</code></pre>"},{"location":"getting-started/pages/#navigation-drawer","title":"Navigation Drawer","text":"Python<pre><code>class HomePage(FletXPage):\n    def build_drawer(self):\n        \"\"\"Override to create drawer\"\"\"\n        return ft.NavigationDrawer(\n            controls=[\n                ft.NavigationDrawerDestination(\n                    label=\"Home\",\n                    icon=ft.icons.HOME\n                ),\n                ft.NavigationDrawerDestination(\n                    label=\"Products\",\n                    icon=ft.icons.SHOPPING_BAG\n                ),\n                ft.NavigationDrawerDestination(\n                    label=\"Settings\",\n                    icon=ft.icons.SETTINGS\n                )\n            ]\n        )\n\n    def build(self):\n        return ft.Column([\n            ft.ElevatedButton(\n                \"Open Drawer\",\n                on_click=lambda _: self.open_drawer()\n            )\n        ])\n</code></pre>"},{"location":"getting-started/pages/#floating-action-button","title":"Floating Action Button","text":"Python<pre><code>class TasksPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = TaskController()\n\n    def build_floating_action_button(self):\n        return ft.FloatingActionButton(\n            icon=ft.icons.ADD,\n            on_click=self._show_add_dialog\n        )\n\n    def _show_add_dialog(self, e):\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Add Task\"),\n            content=ft.TextField(label=\"Task name\"),\n            actions=[\n                ft.TextButton(\"Cancel\"),\n                ft.TextButton(\"Add\")\n            ]\n        )\n        self.page_instance.dialog = dialog\n        dialog.open = True\n        self.page_instance.update()\n\n    def build(self):\n        return ft.Column([ft.Text(\"Your Tasks\")])\n</code></pre>"},{"location":"getting-started/pages/#bottom-sheet","title":"Bottom Sheet","text":"Python<pre><code>def open_filters(self, e):\n    \"\"\"Show filter options in bottom sheet\"\"\"\n    sheet_content = ft.Column([\n        ft.Text(\"Filters\", size=20, weight=\"bold\"),\n        ft.Checkbox(label=\"Active only\"),\n        ft.Checkbox(label=\"Recent\"),\n        ft.ElevatedButton(\"Apply\")\n    ], spacing=15)\n\n    self.open_bottom_sheet(sheet_content)\n</code></pre>"},{"location":"getting-started/pages/#event-handling","title":"Event Handling","text":""},{"location":"getting-started/pages/#window-events","title":"Window Events","text":"Python<pre><code>class ResponsivePage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.window_width = 0\n        self.window_height = 0\n\n    def on_init(self):\n        # Listen to window resize\n        self.on_resize(self._on_window_resize)\n\n        # Listen to media changes (orientation)\n        self.on_media_change(self._on_media_change)\n\n        # Listen to brightness changes\n        self.on_brigthness_change(self._on_brightness_change)\n\n    def _on_window_resize(self, e):\n        \"\"\"When window is resized\"\"\"\n        self.window_width = e.width\n        self.window_height = e.height\n        print(f\"Window: {self.window_width}x{self.window_height}\")\n        self.refresh()\n\n    def _on_media_change(self, e):\n        \"\"\"When orientation changes\"\"\"\n        print(f\"Media changed: {e.data}\")\n        self.refresh()\n\n    def _on_brightness_change(self, e):\n        \"\"\"When system brightness changes\"\"\"\n        print(f\"Brightness changed\")\n\n    @obx\n    def build(self):\n        return ft.Text(f\"{self.window_width}x{self.window_height}\")\n</code></pre>"},{"location":"getting-started/pages/#keyboard-events","title":"Keyboard Events","text":"Python<pre><code>class SearchPage(FletXPage):\n    def __init__(self):\n        super().__init__(enable_keyboard_shortcuts=True)\n        self.search_input = ft.TextField()\n\n    def on_init(self):\n        # Listen to all keyboard events\n        self.on_keyboard(self._on_keyboard)\n\n        # Or register specific shortcuts\n        self.add_keyboard_shortcut(\"ctrl+f\", self._focus_search, \"Focus search\")\n        self.add_keyboard_shortcut(\"escape\", self._clear_search, \"Clear search\")\n\n    def _on_keyboard(self, e):\n        \"\"\"Handle any keyboard event\"\"\"\n        if e.key == \"Enter\":\n            self._do_search()\n\n    def _focus_search(self):\n        self.search_input.focus()\n\n    def _clear_search(self):\n        self.search_input.value = \"\"\n        self.search_input.update()\n\n    def _do_search(self):\n        print(f\"Searching for: {self.search_input.value}\")\n\n    def build(self):\n        return ft.Column([\n            self.search_input,\n            ft.Text(\"Shortcuts: Ctrl+F to focus, Escape to clear\")\n        ])\n</code></pre>"},{"location":"getting-started/pages/#scroll-events","title":"Scroll Events","text":"Python<pre><code>class InfiniteScrollPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.list_view = ft.ListView()\n\n    def on_init(self):\n        self.on_scroll(self._on_scroll)\n\n    def _on_scroll(self, e):\n        \"\"\"When user scrolls\"\"\"\n        print(f\"Scroll offset: {e.offset}\")\n        # Load more items when near bottom\n        if e.offset &gt; 0.8:  # 80% scrolled\n            self._load_more_items()\n\n    def _load_more_items(self):\n        print(\"Loading more items...\")\n\n    def build(self):\n        return ft.Column([\n            self.list_view\n        ])\n</code></pre>"},{"location":"getting-started/pages/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>Make your app more productive with shortcuts:</p> Python<pre><code>class EditorPage(FletXPage):\n    def __init__(self):\n        super().__init__(enable_keyboard_shortcuts=True)\n        self.editor = ft.TextField(multiline=True, min_lines=10)\n\n    def on_init(self):\n        # Register shortcuts\n        self.add_keyboard_shortcut(\"ctrl+s\", self._save, \"Save\")\n        self.add_keyboard_shortcut(\"ctrl+n\", self._new, \"New\")\n        self.add_keyboard_shortcut(\"ctrl+o\", self._open, \"Open\")\n        self.add_keyboard_shortcut(\"ctrl+z\", self._undo, \"Undo\")\n        self.add_keyboard_shortcut(\"ctrl+y\", self._redo, \"Redo\")\n\n    def _save(self):\n        print(\"Saving...\")\n\n    def _new(self):\n        self.editor.value = \"\"\n        self.editor.update()\n\n    def _open(self):\n        print(\"Opening file...\")\n\n    def _undo(self):\n        print(\"Undo...\")\n\n    def _redo(self):\n        print(\"Redo...\")\n\n    def build(self):\n        shortcuts = self.get_keyboard_shortcuts()\n        shortcuts_text = \"\\n\".join(\n            [f\"{k}: {v['description']}\" for k, v in shortcuts.items()]\n        )\n\n        return ft.Column([\n            ft.Text(\"Shortcuts:\"),\n            ft.Text(shortcuts_text, size=10),\n            self.editor\n        ])\n</code></pre>"},{"location":"getting-started/pages/#gestures","title":"Gestures","text":"<p>Handle touch and mouse gestures:</p> Python<pre><code>class GesturesPage(FletXPage):\n    def __init__(self):\n        super().__init__(enable_gestures=True)\n\n    def on_init(self):\n        # Handle tap\n        self.on_tap(self._on_tap)\n\n        # Handle long press\n        self.on_long_press(self._on_long_press)\n\n        # Handle scale/zoom\n        self.on_scale(self._on_scale)\n\n    def _on_tap(self, e):\n        print(f\"Tapped at {e.local_x}, {e.local_y}\")\n\n    def _on_long_press(self, e):\n        print(f\"Long pressed at {e.local_x}, {e.local_y}\")\n\n    def _on_scale(self, e):\n        print(f\"Scale: {e.scale}\")\n\n    def build(self):\n        return ft.Column([\n            ft.Text(\"Tap, long press, or scale me!\")\n        ])\n</code></pre>"},{"location":"getting-started/pages/#dialogs-and-alerts","title":"Dialogs and Alerts","text":"Python<pre><code>class DialogsPage(FletXPage):\n    def build(self):\n        return ft.Column([\n            ft.ElevatedButton(\"Alert\", on_click=self._show_alert),\n            ft.ElevatedButton(\"Confirm\", on_click=self._show_confirm),\n            ft.ElevatedButton(\"Loader\", on_click=self._show_loader),\n            ft.ElevatedButton(\"Snackbar\", on_click=self._show_snackbar)\n        ])\n\n    def _show_alert(self, e):\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Alert\"),\n            content=ft.Text(\"This is an alert message\"),\n            actions=[ft.TextButton(\"OK\")]\n        )\n        self.page_instance.dialog = dialog\n        dialog.open = True\n        self.page_instance.update()\n\n    def _show_confirm(self, e):\n        dialog = ft.AlertDialog(\n            title=ft.Text(\"Confirm?\"),\n            content=ft.Text(\"Are you sure?\"),\n            actions=[\n                ft.TextButton(\"Cancel\"),\n                ft.TextButton(\"Yes\", style=ft.ButtonStyle(color=ft.colors.RED))\n            ]\n        )\n        self.page_instance.dialog = dialog\n        dialog.open = True\n        self.page_instance.update()\n\n    def _show_loader(self, e):\n        self.show_loader(ft.ProgressRing())\n\n    def _show_snackbar(self, e):\n        snack = ft.SnackBar(ft.Text(\"Operation completed!\"))\n        self.page_instance.snack_bar = snack\n        snack.open = True\n        self.page_instance.update()\n</code></pre>"},{"location":"getting-started/pages/#effects-and-side-effects","title":"Effects and Side Effects","text":"Python<pre><code>class EffectsPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = MyController()\n\n    def on_init(self):\n        # Watch for changes\n        self.watch(\n            self.controller.username,\n            self._on_username_change\n        )\n\n        # Watch multiple\n        self.watch_multiple(\n            [self.controller.email, self.controller.phone],\n            self._on_contact_change\n        )\n\n        # Add effect with cleanup\n        self.add_effect(\n            self._setup_listener,\n            cleanup_fn=self._cleanup_listener\n        )\n\n    def _on_username_change(self):\n        print(f\"Username changed to: {self.controller.username}\")\n\n    def _on_contact_change(self):\n        print(\"Contact info changed\")\n\n    def _setup_listener(self):\n        print(\"Setting up listener...\")\n\n    def _cleanup_listener(self):\n        print(\"Cleaning up listener...\")\n\n    def build(self):\n        return ft.Text(\"Effects demo\")\n</code></pre>"},{"location":"getting-started/pages/#page-configuration","title":"Page Configuration","text":"Python<pre><code>class StyledPage(FletXPage):\n    def __init__(self):\n        super().__init__(\n            # Layout\n            padding=20,\n            bgcolor=ft.colors.SURFACE_VARIANT,\n\n            # Styling\n            border_radius=10,\n\n            # Features\n            enable_keyboard_shortcuts=True,\n            enable_gestures=True,\n            safe_area=True,\n\n            # Lifecycle\n            auto_dispose_controllers=True\n        )\n\n    def on_init(self):\n        # Set page title\n        self.set_title(\"My Page\")\n\n        # Set theme\n        self.set_theme_mode(ft.ThemeMode.LIGHT)\n\n    def build(self):\n        return ft.Text(\"Styled page\")\n</code></pre>"},{"location":"getting-started/pages/#performance-monitoring","title":"Performance Monitoring","text":"Python<pre><code>class AnalyticsPage(FletXPage):\n    def on_destroy(self):\n        # Get performance stats\n        stats = self.get_performance_stats()\n\n        print(f\"Render time: {stats['average_render_time']:.2f}ms\")\n        print(f\"Updates: {stats['update_count']}\")\n        print(f\"Controllers: {stats['controller_count']}\")\n\n    def build(self):\n        return ft.Text(\"Performance tracked\")\n</code></pre>"},{"location":"getting-started/pages/#complete-real-world-example","title":"Complete Real-World Example","text":"Python<pre><code>from fletx.core import FletXPage, FletXController\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass BookController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.books = self.create_rx_list([])\n        self.selected_book = self.create_rx_str(\"\")\n        self.filter_text = self.create_rx_str(\"\")\n\n    def load_books(self):\n        self.set_loading(True)\n        try:\n            self.books.value = [\n                {\"id\": 1, \"title\": \"Python Guide\", \"author\": \"John Doe\"},\n                {\"id\": 2, \"title\": \"Web Dev\", \"author\": \"Jane Smith\"},\n                {\"id\": 3, \"title\": \"AI Basics\", \"author\": \"Bob Johnson\"}\n            ]\n            self.emit_local(\"books_loaded\", len(self.books))\n        finally:\n            self.set_loading(False)\n\n    def select_book(self, book_id):\n        book = next((b for b in self.books if b[\"id\"] == book_id), None)\n        if book:\n            self.selected_book.value = book[\"title\"]\n\nclass BooksPage(FletXPage):\n    def __init__(self):\n        super().__init__(padding=20)\n        self.controller = BookController()\n\n    def build_app_bar(self):\n        return ft.AppBar(\n            title=ft.Text(\"Books Library\"),\n            center_title=True\n        )\n\n    def on_init(self):\n        self.controller.load_books()\n        self.controller.on_local(\"books_loaded\", self._on_loaded)\n\n    def _on_loaded(self, event):\n        print(f\"Loaded {event.data} books\")\n\n    @obx\n    def build(self):\n        if self.controller.is_loading:\n            return ft.Center(content=ft.ProgressRing())\n\n        return ft.Column([\n            ft.Text(f\"Books ({len(self.controller.books)})\", size=24),\n            ft.ListView([\n                ft.ListTile(\n                    title=ft.Text(book[\"title\"]),\n                    subtitle=ft.Text(book[\"author\"]),\n                    on_click=lambda _, b=book: self.controller.select_book(b[\"id\"])\n                )\n                for book in self.controller.books\n            ]),\n            ft.Divider(),\n            ft.Text(\n                f\"Selected: {self.controller.selected_book if self.controller.selected_book else 'None'}\"\n            )\n        ])\n</code></pre>"},{"location":"getting-started/pages/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/pages/#1-initialize-in-on_init-not-__init__","title":"1. Initialize in <code>on_init()</code>, not <code>__init__()</code>","text":"Python<pre><code># \u2705 Good\nclass MyPage(FletXPage):\n    def on_init(self):\n        # Page is now visible\n        self.controller.load_data()\n\n# \u274c Avoid\nclass MyPage(FletXPage):\n    def __init__(self):\n        # Page not visible yet!\n        self.controller.load_data()\n</code></pre>"},{"location":"getting-started/pages/#2-clean-up-in-on_destroy","title":"2. Clean Up in <code>on_destroy()</code>","text":"Python<pre><code>def on_destroy(self):\n    # Cancel requests\n    self.controller.cancel_all()\n\n    # Close connections\n    if hasattr(self, 'ws'):\n        self.ws.close()\n</code></pre>"},{"location":"getting-started/pages/#3-use-controller-methods-correctly","title":"3. Use Controller Methods Correctly","text":"Python<pre><code># \u2705 Good - use create_rx_* for initialization\nclass MyController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.count = self.create_rx_int(0)\n        self.name = self.create_rx_str(\"\")\n        self.items = self.create_rx_list([])\n\n# \u2705 Good - use set_* methods for updates\nself.controller.set_loading(True)\nself.controller.set_error(\"Error message\")\n\n# \u274c Avoid - don't use RxInt/RxStr directly\nself.controller.count = RxInt(0)  # Wrong!\n\n# \u274c Avoid - don't set reactive properties directly\nself.controller.is_loading = True  # Won't trigger updates\n</code></pre>"},{"location":"getting-started/pages/#4-keep-pages-focused","title":"4. Keep Pages Focused","text":"Python<pre><code># \u2705 Good - one responsibility\nclass UserListPage(FletXPage):\n    pass\n\n# \u274c Avoid - too many responsibilities  \nclass AdminPage(FletXPage):\n    # Shows users, analytics, settings, logs...\n    pass\n</code></pre>"},{"location":"getting-started/pages/#5-use-obx-for-reactive-methods","title":"5. Use @obx for Reactive Methods","text":"Python<pre><code># \u2705 Good - method marked with @obx rebuilds automatically\n@obx\ndef user_card(self):\n    return ft.Card(content=ft.Text(self.controller.username))\n\n# \u274c Avoid - regular method won't react to changes\ndef user_card(self):\n    return ft.Card(content=ft.Text(self.controller.username))\n</code></pre>"},{"location":"getting-started/pages/#summary","title":"Summary","text":"Feature Purpose <code>build()</code> Return the page UI <code>on_init()</code> Setup when page appears <code>on_destroy()</code> Cleanup when page disappears <code>build_app_bar()</code> Custom app bar <code>build_drawer()</code> Navigation drawer <code>build_floating_action_button()</code> FAB <code>add_keyboard_shortcut()</code> Register shortcut <code>on_resize()</code> Window resize event <code>on_keyboard()</code> Keyboard event <code>on_scroll()</code> Scroll event <code>on_tap()</code> / <code>on_long_press()</code> / <code>on_scale()</code> Gesture events <code>page_instance</code> Access Flet page <code>refresh()</code> Force UI update <code>open_drawer()</code> / <code>close_drawer()</code> Drawer control <code>open_bottom_sheet()</code> Show bottom sheet <code>show_loader()</code> Show loading dialog <code>controller</code> Business logic <code>watch()</code> React to state changes <code>get_performance_stats()</code> Performance info"},{"location":"getting-started/pages/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Controllers for managing state</li> <li>Explore Routing to navigate between pages</li> <li>Understand Dependency Injection</li> <li>Read about State Management with reactive variables</li> <li>Check Decorators for advanced features</li> </ul>"},{"location":"getting-started/routing/","title":"Routing","text":"<p>TL;DR: If you're coming from Flet, think of FletX routing like Angular/Vue Router for pages. Instead of manually managing <code>page.route</code> and <code>page.go()</code>, you declaratively define routes and let FletX handle the page lifecycle.</p>"},{"location":"getting-started/routing/#what-is-routing","title":"What is Routing?","text":"<p>Routing in FletX manages navigation between different pages in your application. Instead of manually showing and hiding controls, you define routes that map URL paths to page components. When a user navigates to a path, FletX automatically displays the corresponding page.</p>"},{"location":"getting-started/routing/#why-fletx-has-its-own-routing","title":"Why FletX Has Its Own Routing","text":"<p>Flet provides basic navigation through <code>page.route</code> and <code>page.go()</code>, but this approach requires manual page management. FletX builds on top of Flet's navigation to provide:</p> <ul> <li>Declarative route definitions: Define all routes in one place</li> <li>Automatic page lifecycle: Components are created and destroyed automatically</li> <li>Data passing: Send data between pages without global variables</li> <li>Route parameters: Handle dynamic paths like <code>/user/123</code></li> <li>Protection: Guard sensitive routes with authentication checks</li> <li>History management: Built-in back/forward navigation</li> </ul> <p>Flet vs FletX comparison:</p> Python<pre><code># Flet (manual navigation)\npage.go(\"/settings\")\n\n# FletX (declarative routing)\nnavigate(\"/settings\")  # Automatically handles page lifecycle\n</code></pre>"},{"location":"getting-started/routing/#your-first-route","title":"Your First Route","text":"<p>Let's create a simple app with one route. First, define a page component:</p> Python<pre><code>import flet as ft\nfrom fletx.core import FletXPage\n\nclass HomePage(FletXPage):\n    def build(self):\n        return ft.Text(\"Welcome to the home page\")\n</code></pre> <p>Now create your main app and register the route:</p> Python<pre><code>from fletx import FletXApp\nfrom fletx.navigation import router_config\n\n# Register the route\nrouter_config.add_routes([\n    {\"path\": \"/\", \"component\": HomePage}\n])\n\n# Run the app\napp = FletXApp()\napp.run()\n</code></pre> <p>When the app starts, FletX navigates to <code>/</code> and displays your <code>HomePage</code> component.</p> <p>How it works: - <code>path</code>: The URL path to match (e.g., <code>/</code>, <code>/about</code>, <code>/settings</code>) - <code>component</code>: The page class to display when the path matches - FletX calls <code>build()</code> on your component to render the page</p>"},{"location":"getting-started/routing/#multiple-routes-and-navigation","title":"Multiple Routes and Navigation","text":"<p>Let's add a second page and navigate between them:</p> Python<pre><code>from fletx.core import FletXPage\nfrom fletx.navigation import navigate\nimport flet as ft\n\nclass HomePage(FletXPage):\n    def build(self):\n        return ft.Column([\n            ft.Text(\"Home Page\"),\n            ft.ElevatedButton(\n                \"Go to Settings\",\n                on_click=lambda _: navigate(\"/settings\")\n            )\n        ])\n\nclass SettingsPage(FletXPage):\n    def build(self):\n        return ft.Column([\n            ft.Text(\"Settings Page\"),\n            ft.ElevatedButton(\n                \"Go Back\",\n                on_click=lambda _: navigate(\"/\")\n            )\n        ])\n</code></pre> <p>Register both routes:</p> Python<pre><code>from fletx.navigation import router_config\n\nrouter_config.add_routes([\n    {\"path\": \"/\", \"component\": HomePage},\n    {\"path\": \"/settings\", \"component\": SettingsPage}\n])\n</code></pre>"},{"location":"getting-started/routing/#going-back","title":"Going Back","text":"<p>Instead of navigating to a specific path, you can go back to the previous page:</p> Python<pre><code>from fletx.navigation import go_back\n\nft.ElevatedButton(\"Back\", on_click=lambda _: go_back())\n</code></pre> <p>This works like the browser's back button, returning to the last visited page.</p>"},{"location":"getting-started/routing/#passing-data-between-routes","title":"Passing Data Between Routes","text":"<p>Often you need to send data from one page to another. For example, clicking an item in a list to see its details.</p> <p>Sending page:</p> Python<pre><code>class ProductListPage(FletXPage):\n    def build(self):\n        def view_product(product_id, product_name):\n            navigate(\"/product-details\", data={\n                \"id\": product_id,\n                \"name\": product_name\n            })\n\n        return ft.Column([\n            ft.ElevatedButton(\n                \"View Product A\",\n                on_click=lambda _: view_product(101, \"Widget A\")\n            ),\n            ft.ElevatedButton(\n                \"View Product B\",\n                on_click=lambda _: view_product(102, \"Widget B\")\n            )\n        ])\n</code></pre> <p>Receiving page:</p> Python<pre><code>class ProductDetailsPage(FletXPage):\n    def build(self):\n        # Access the data passed from the previous page\n        product_data = self.route_info.data\n        product_id = product_data.get(\"id\")\n        product_name = product_data.get(\"name\")\n\n        return ft.Column([\n            ft.Text(f\"Product: {product_name}\"),\n            ft.Text(f\"ID: {product_id}\")\n        ])\n</code></pre> <p>Register the route:</p> Python<pre><code>router_config.add_routes([\n    {\"path\": \"/products\", \"component\": ProductListPage},\n    {\"path\": \"/product-details\", \"component\": ProductDetailsPage}\n])\n</code></pre> <p>When to use data passing: - Temporary data for a single navigation (like form data or selected item details) - Data that doesn't need to persist across multiple page changes</p>"},{"location":"getting-started/routing/#dynamic-routes-with-parameters","title":"Dynamic Routes with Parameters","text":"<p>For URLs like <code>/user/123</code> or <code>/post/my-article</code>, use route parameters:</p> Python<pre><code>router_config.add_routes([\n    {\"path\": \"/user/:user_id\", \"component\": UserProfilePage}\n])\n</code></pre> <p>The <code>:user_id</code> part matches any value in that position. Access it in your page:</p> Python<pre><code>class UserProfilePage(FletXPage):\n    def build(self):\n        # Get the user_id from the URL\n        user_id = self.route_info.params.get(\"user_id\")\n\n        return ft.Column([\n            ft.Text(f\"Viewing profile for user: {user_id}\"),\n            # Load user data based on user_id...\n        ])\n</code></pre> <p>Navigate to these routes normally:</p> Python<pre><code># This will match /user/:user_id and set user_id to \"123\"\nnavigate(\"/user/123\")\n\n# This will match /user/:user_id and set user_id to \"alice\"\nnavigate(\"/user/alice\")\n</code></pre> <p>Multiple parameters:</p> Python<pre><code>router_config.add_routes([\n    {\"path\": \"/blog/:category/:post_id\", \"component\": BlogPostPage}\n])\n\n# Access both parameters\nclass BlogPostPage(FletXPage):\n    def build(self):\n        category = self.route_info.params.get(\"category\")\n        post_id = self.route_info.params.get(\"post_id\")\n\n        return ft.Text(f\"Category: {category}, Post: {post_id}\")\n</code></pre>"},{"location":"getting-started/routing/#nested-routes","title":"Nested Routes","text":"<p>When building apps with shared layouts (like an admin panel with a sidebar), nested routes let you reuse parent layouts while changing child content.</p> Python<pre><code>from fletx.navigation import RouteDefinition\n\n# Parent layout with sidebar\nclass AdminLayoutPage(FletXPage):\n    def build(self):\n        return ft.Row([\n            ft.Container(\n                content=ft.Text(\"Sidebar\"),\n                width=200,\n                bgcolor=ft.colors.BLUE_GREY_100\n            ),\n            ft.Container(\n                # Child routes render here\n                expand=True\n            )\n        ])\n\n# Register parent with children\nrouter_config.add_route(\n    path=\"/admin\",\n    component=AdminLayoutPage,\n    children=[\n        RouteDefinition(path=\"/dashboard\", component=AdminDashboardPage),\n        RouteDefinition(path=\"/users\", component=AdminUsersPage)\n    ]\n)\n</code></pre> <p>Now navigating to <code>/admin/dashboard</code> or <code>/admin/users</code> will show the same sidebar with different content.</p>"},{"location":"getting-started/routing/#protected-routes-with-guards","title":"Protected Routes with Guards","text":"<p>Route guards check conditions before allowing navigation. This is useful for authentication:</p> Python<pre><code>from fletx.navigation import RouteGuard\n\nclass AuthGuard(RouteGuard):\n    def __init__(self, auth_service):\n        self.auth_service = auth_service\n\n    async def can_activate(self, route_info):\n        # Return True to allow, False to block\n        return self.auth_service.is_logged_in()\n\n    async def can_deactivate(self, route_info):\n        # Optional: always allow leaving this route\n        return True\n\n    async def redirect_to(self, route_info):\n        # Where to redirect if blocked\n        return \"/login\"\n</code></pre> <p>Apply the guard to routes:</p> Python<pre><code># Assume you have an auth_service instance\nauth_service = AuthService()\n\nrouter_config.add_routes([\n    {\"path\": \"/login\", \"component\": LoginPage},\n    {\n        \"path\": \"/dashboard\",\n        \"component\": DashboardPage,\n        \"guards\": [AuthGuard(auth_service)]  # Protected route\n    }\n])\n</code></pre> <p>Now if a user tries to access <code>/dashboard</code> without being logged in, they'll be redirected to <code>/login</code>.</p>"},{"location":"getting-started/routing/#state-and-controllers","title":"State and Controllers","text":"<p>When you navigate between pages, FletX destroys the previous page component and creates a new one. This means page-level state is lost.</p> <p>To preserve state across navigation:</p> <p>Use Controllers (Services)</p> <p>Controllers exist outside the page lifecycle and maintain state:</p> Python<pre><code># cart_service.py\nclass CartService:\n    def __init__(self):\n        self.items = []\n\n    def add_item(self, item):\n        self.items.append(item)\n\n    def get_items(self):\n        return self.items\n</code></pre> <p>Use the same controller instance across pages:</p> Python<pre><code># In your app setup\ncart_service = CartService()\n\nclass ProductPage(FletXPage):\n    def build(self):\n        def add_to_cart():\n            cart_service.add_item({\"name\": \"Widget\", \"price\": 10})\n\n        return ft.ElevatedButton(\"Add to Cart\", on_click=lambda _: add_to_cart())\n\nclass CartPage(FletXPage):\n    def build(self):\n        items = cart_service.get_items()\n        return ft.Column([\n            ft.Text(f\"Cart has {len(items)} items\")\n        ])\n</code></pre> <p>Even though you navigate between pages, the <code>cart_service</code> maintains its state.</p>"},{"location":"getting-started/routing/#advanced-features","title":"Advanced Features","text":""},{"location":"getting-started/routing/#modular-routing","title":"Modular Routing","text":"<p>For large applications, organize routes by feature using <code>ModuleRouter</code>:</p> Python<pre><code>from fletx.navigation import ModuleRouter\n\n# Create a module for admin routes\nadmin_module = ModuleRouter()\nadmin_module.add_routes([\n    {\"path\": \"/\", \"component\": AdminHomePage},\n    {\"path\": \"/users\", \"component\": AdminUsersPage}\n])\n\n# Mount the module under /admin\nrouter_config.add_module_routes(\"/admin\", admin_module)\n</code></pre> <p>This creates routes at <code>/admin/</code> and <code>/admin/users</code>.</p> <p>Decorator-based registration (similar to Angular):</p> Python<pre><code>from fletx.decorators import register_router\n\n@register_router\nclass AdminRouter(ModuleRouter):\n    name = 'Admin'\n    base_path = '/admin'\n    is_root = False\n    routes = [\n        {\"path\": \"/\", \"component\": AdminHomePage},\n        {\"path\": \"/users\", \"component\": AdminUsersPage}\n    ]\n    sub_routers = []\n</code></pre>"},{"location":"getting-started/routing/#page-transitions","title":"Page Transitions","text":"<p>Add animations when navigating between pages:</p> Python<pre><code>from fletx.navigation import RouteTransition, TransitionType\n\nrouter_config.add_routes([\n    {\n        \"path\": \"/login\",\n        \"component\": LoginPage,\n        \"meta\": {\n            \"transition\": RouteTransition(\n                transition_type=TransitionType.ZOOM_IN,\n                duration=350\n            )\n        }\n    }\n])\n</code></pre>"},{"location":"getting-started/routing/#middleware","title":"Middleware","text":"<p>Run code before and after navigation:</p> Python<pre><code>from fletx.navigation import RouteMiddleware\n\nclass LoggingMiddleware(RouteMiddleware):\n    def before_navigation(self, from_route, to_route):\n        print(f\"Navigating from {from_route.path} to {to_route.path}\")\n\n    def after_navigation(self, route_info):\n        print(f\"Arrived at {route_info.path}\")\n\nrouter_config.add_route(\n    path=\"/analytics\",\n    component=AnalyticsPage,\n    middleware=[LoggingMiddleware()]\n)\n</code></pre>"},{"location":"getting-started/routing/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/routing/#organize-routes-in-files","title":"Organize Routes in Files","text":"<p>For maintainability, define routes in a separate file:</p> Python<pre><code># routes.py\nfrom fletx.navigation import router_config\nfrom pages import HomePage, SettingsPage, ProfilePage\n\ndef setup_routes():\n    router_config.add_routes([\n        {\"path\": \"/\", \"component\": HomePage},\n        {\"path\": \"/settings\", \"component\": SettingsPage},\n        {\"path\": \"/profile/:user_id\", \"component\": ProfilePage}\n    ])\n\n# main.py\nfrom fletx import FletXApp\nfrom routes import setup_routes\n\nsetup_routes()\napp = FletXApp()\napp.run()\n</code></pre>"},{"location":"getting-started/routing/#use-constants-for-paths","title":"Use Constants for Paths","text":"<p>Avoid hardcoding paths throughout your app:</p> Python<pre><code># constants.py\nclass Routes:\n    HOME = \"/\"\n    SETTINGS = \"/settings\"\n    PROFILE = \"/profile\"\n\n# Usage\nnavigate(Routes.SETTINGS)\n</code></pre>"},{"location":"getting-started/routing/#data-passing-guidelines","title":"Data Passing Guidelines","text":"<ul> <li>Route data: Use for temporary data in a single navigation flow</li> <li>Controllers/Services: Use for app-wide state that persists across navigation</li> <li>Route parameters: Use for identifiers that should appear in the URL</li> </ul>"},{"location":"getting-started/routing/#keep-pages-focused","title":"Keep Pages Focused","text":"<p>Pages should handle UI rendering. Move business logic to controllers:</p> Python<pre><code># Good\nclass ProductPage(FletXPage):\n    def build(self):\n        products = product_service.get_all()  # Service handles logic\n        return ft.Column([...])\n\n# Avoid\nclass ProductPage(FletXPage):\n    def build(self):\n        # Don't put database queries and business logic here\n        connection = connect_to_db()\n        products = connection.query(\"SELECT * FROM products\")\n        ...\n</code></pre>"},{"location":"getting-started/routing/#summary","title":"Summary","text":"Feature Purpose <code>router_config.add_routes()</code> Define path-to-component mappings <code>navigate(path)</code> Navigate to a route programmatically <code>go_back()</code> Return to the previous page <code>navigate(path, data={...})</code> Pass data to the next page Route parameters (<code>:param</code>) Handle dynamic URL segments <code>RouteGuard</code> Protect routes with conditions <code>ModuleRouter</code> Organize routes by feature <code>RouteTransition</code> Add page animations <code>RouteMiddleware</code> Hook into navigation lifecycle"},{"location":"getting-started/routing/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Controllers for managing application state</li> <li>Explore Dependency Injection for providing services to pages</li> <li>Understand Services for shared business logic</li> </ul>"},{"location":"getting-started/services/","title":"Services","text":"<p>TL;DR: A <code>FletXService</code> is a reusable component for handling external systems (APIs, databases, hardware, storage). Services have a lifecycle (<code>on_start()</code>, <code>on_ready()</code>, <code>on_stop()</code>, <code>on_dispose()</code>), built-in HTTP client, state management (<code>IDLE</code>, <code>LOADING</code>, <code>READY</code>, <code>ERROR</code>), and data storage. Use them to keep controllers lean and focused on business logic.</p>"},{"location":"getting-started/services/#what-is-a-fletxservice","title":"What is a FletXService?","text":"<p>A <code>FletXService</code> is a specialized component for handling external communication and heavy lifting:</p> <ul> <li>HTTP/API calls - With built-in HTTP client</li> <li>Database operations - Queries, persistence, transactions</li> <li>File operations - Reading, writing, uploading files</li> <li>Hardware access - Camera, GPS, sensors, etc.</li> <li>Caching - In-memory or persistent caches</li> <li>Authentication - Token management, OAuth flows</li> <li>WebSocket connections - Real-time communication</li> <li>Background tasks - Long-running operations</li> </ul> <p>Services separate concerns from controllers, making your code:</p> <ul> <li>Easier to test (mock services easily)</li> <li>More reusable (share services across pages)</li> <li>More maintainable (external logic isolated)</li> <li>More scalable (handle complex operations cleanly)</li> </ul>"},{"location":"getting-started/services/#why-services","title":"Why Services?","text":"<p>Without Services - Logic Scattered:</p> Python<pre><code>class UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.user = self.create_rx_dict({})\n\n    def fetch_user(self, user_id):\n        # API call logic mixed with controller\n        import requests\n        try:\n            response = requests.get(f\"https://api.example.com/users/{user_id}\")\n            self.user.value = response.json()\n        except Exception as e:\n            self.error_message.value = str(e)\n\n        # Parse response, validate, cache, retry logic...\n        # All here in the controller!\n</code></pre> <p>Problems:</p> <ul> <li>Controller is overloaded</li> <li>Hard to test API logic</li> <li>Difficult to reuse API calls in other controllers</li> <li>External logic mixed with business logic</li> <li>No error handling strategy</li> </ul> <p>With Services - Clean Separation:</p> Python<pre><code>class UserAPIService(FletXService):\n    def __init__(self):\n        super().__init__(http_client=HTTPClient(\"https://api.example.com\"))\n\n    def fetch_user(self, user_id):\n        try:\n            response = self.http_client.get(f\"/users/{user_id}\")\n            return response.json()\n        except Exception as e:\n            self.set_error(e)\n            return None\n\nclass UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.user = self.create_rx_dict({})\n        self.user_service = UserAPIService()\n\n    def fetch_user(self, user_id):\n        user_data = self.user_service.fetch_user(user_id)\n        if user_data:\n            self.user.value = user_data\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Services handle external logic</li> <li>\u2705 Controllers focus on state and UI logic</li> <li>\u2705 Easy to test (mock service)</li> <li>\u2705 Easy to reuse across controllers</li> <li>\u2705 Clear separation of concerns</li> </ul>"},{"location":"getting-started/services/#your-first-service","title":"Your First Service","text":""},{"location":"getting-started/services/#step-1-create-a-service","title":"Step 1: Create a Service","text":"Python<pre><code>from fletx.core import FletXService, HTTPClient\n\nclass WeatherService(FletXService):\n    def __init__(self):\n        super().__init__(\n            name=\"WeatherService\",\n            http_client=HTTPClient(\"https://api.weather.example.com\")\n        )\n\n    def get_weather(self, city):\n        response = self.http_client.get(f\"/weather?city={city}\")\n        return response.json()\n</code></pre>"},{"location":"getting-started/services/#step-2-use-in-a-controller","title":"Step 2: Use in a Controller","text":"Python<pre><code>from fletx.core import FletXController\n\nclass WeatherController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.weather = self.create_rx_dict({})\n        self.weather_service = WeatherService()\n\n    def fetch_weather(self, city):\n        data = self.weather_service.get_weather(city)\n        self.weather.value = data\n</code></pre>"},{"location":"getting-started/services/#step-3-use-in-a-page","title":"Step 3: Use in a Page","text":"Python<pre><code>from fletx.core import FletXPage\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass WeatherPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = WeatherController()\n\n    @obx\n    def build(self):\n        return ft.Column([\n            ft.TextField(label=\"City\"),\n            ft.ElevatedButton(\n                \"Get Weather\",\n                on_click=lambda _: self.controller.fetch_weather(\"Paris\")\n            ),\n            ft.Text(f\"Weather: {self.controller.weather.get('condition', '')}\")\n        ])\n</code></pre> <p>Done! \ud83c\udf89</p>"},{"location":"getting-started/services/#service-lifecycle","title":"Service Lifecycle","text":"<p>Services go through clear stages:</p> Text Only<pre><code>IDLE \u2192 LOADING \u2192 READY \u2192 (ERROR) \u2192 (IDLE) \u2192 DISPOSED\n</code></pre>"},{"location":"getting-started/services/#lifecycle-states","title":"Lifecycle States","text":"State When What You Can Do <code>IDLE</code> Created, not started Initial state <code>LOADING</code> Starting service Initialization in progress <code>READY</code> Ready to use Handle requests <code>ERROR</code> Error occurred Handle error, retry, or stop <code>DISPOSED</code> Cleanup complete Resources freed"},{"location":"getting-started/services/#lifecycle-hooks","title":"Lifecycle Hooks","text":"Python<pre><code>class DatabaseService(FletXService):\n    def __init__(self):\n        super().__init__(name=\"DatabaseService\")\n        self.connection = None\n\n    def on_start(self):\n        \"\"\"Called when service starts\"\"\"\n        print(\"Opening database connection...\")\n        self.connection = self._open_connection()\n\n    def on_ready(self):\n        \"\"\"Called when service is ready\"\"\"\n        print(\"Database service is ready!\")\n\n    def on_stop(self):\n        \"\"\"Called when service stops\"\"\"\n        print(\"Closing database connection...\")\n        if self.connection:\n            self.connection.close()\n\n    def on_dispose(self):\n        \"\"\"Called during final cleanup\"\"\"\n        print(\"Database service disposed\")\n        self.connection = None\n\n    def _open_connection(self):\n        # Simulate opening connection\n        return {\"connected\": True}\n</code></pre>"},{"location":"getting-started/services/#async-lifecycle","title":"Async Lifecycle","text":"<p>For services needing async operations:</p> Python<pre><code>class AsyncAPIService(FletXService):\n    async def on_start_async(self):\n        \"\"\"Async version of on_start\"\"\"\n        print(\"Starting async service...\")\n        await self._initialize_async()\n\n    async def on_stop_async(self):\n        \"\"\"Async version of on_stop\"\"\"\n        print(\"Stopping async service...\")\n        await self._cleanup_async()\n\n    async def _initialize_async(self):\n        # Async initialization\n        pass\n\n    async def _cleanup_async(self):\n        # Async cleanup\n        pass\n</code></pre>"},{"location":"getting-started/services/#service-control","title":"Service Control","text":"<p>Start, stop, and restart services:</p> Python<pre><code>service = MyService(auto_start=False)  # Don't auto-start\n\n# Start the service\nservice.start()\n\n# Check if ready\nif service.is_ready:\n    result = service.do_something()\n\n# Restart the service\nservice.restart()\n\n# Stop the service\nservice.stop()\n\n# Dispose and cleanup\nservice.dispose()\n</code></pre>"},{"location":"getting-started/services/#checking-service-state","title":"Checking Service State","text":"Python<pre><code># Check current state\nprint(service.state)  # ServiceState.READY\n\n# Convenience properties\nif service.is_ready:\n    # Service is operational\n    pass\n\nif service.is_loading:\n    # Service is initializing\n    pass\n\nif service.has_error:\n    # Service has error\n    error = service.error\n    print(f\"Error: {error}\")\n</code></pre>"},{"location":"getting-started/services/#built-in-http-client","title":"Built-in HTTP Client","text":"<p>Services include an HTTP client for API communication:</p> Python<pre><code>from fletx.core import FletXService, HTTPClient\n\nclass GitHubService(FletXService):\n    def __init__(self):\n        super().__init__(\n            name=\"GitHubService\",\n            http_client=HTTPClient(\"https://api.github.com\")\n        )\n\n    def get_user(self, username):\n        # GET request\n        response = self.http_client.get(f\"/users/{username}\")\n        return response.json()\n\n    def get_repos(self, username):\n        # GET with parameters\n        response = self.http_client.get(\n            f\"/users/{username}/repos\",\n            params={\"per_page\": 10}\n        )\n        return response.json()\n\n    def create_gist(self, description, content):\n        # POST request\n        response = self.http_client.post(\n            \"/gists\",\n            json={\"description\": description, \"files\": {\"code.py\": {\"content\": content}}}\n        )\n        return response.json()\n\n    def update_repo(self, owner, repo, data):\n        # PATCH request\n        response = self.http_client.patch(\n            f\"/repos/{owner}/{repo}\",\n            json=data\n        )\n        return response.json()\n</code></pre>"},{"location":"getting-started/services/#service-data-storage","title":"Service Data Storage","text":"<p>Services can store and retrieve data:</p> Python<pre><code>class UserCacheService(FletXService):\n    def __init__(self):\n        super().__init__(name=\"UserCacheService\")\n\n    def on_start(self):\n        # Initialize with data\n        self.set_data(\"users\", {})\n        self.set_data(\"last_update\", None)\n\n    def cache_user(self, user_id, user_data):\n        users = self.get_data(\"users\", {})\n        users[user_id] = user_data\n        self.set_data(\"users\", users)\n\n    def get_cached_user(self, user_id):\n        users = self.get_data(\"users\", {})\n        return users.get(user_id)\n\n    def clear_cache(self):\n        self.clear_data()\n</code></pre>"},{"location":"getting-started/services/#data-methods","title":"Data Methods","text":"Python<pre><code># Set individual data\nservice.set_data(\"key\", \"value\")\n\n# Get individual data with default\nvalue = service.get_data(\"key\", default=\"default_value\")\n\n# Get all data (copy)\nall_data = service.data\n\n# Clear all data\nservice.clear_data()\n</code></pre>"},{"location":"getting-started/services/#error-handling","title":"Error Handling","text":"<p>Services provide error management:</p> Python<pre><code>class PaymentService(FletXService):\n    def __init__(self):\n        super().__init__(http_client=HTTPClient(\"https://payment.api.com\"))\n\n    def process_payment(self, amount, card):\n        try:\n            response = self.http_client.post(\n                \"/payment\",\n                json={\"amount\": amount, \"card\": card}\n            )\n            return response.json()\n        except Exception as e:\n            # Set error state\n            self.set_error(e)\n            return None\n\n    def on_state_changed(self):\n        \"\"\"Called when service state changes\"\"\"\n        if self.has_error:\n            print(f\"Payment error: {self.error}\")\n</code></pre>"},{"location":"getting-started/services/#error-properties","title":"Error Properties","text":"Python<pre><code># Check for errors\nif service.has_error:\n    error = service.error\n    print(f\"Error occurred: {error}\")\n\n# Set error manually\nservice.set_error(Exception(\"Something went wrong\"))\n</code></pre>"},{"location":"getting-started/services/#complete-real-world-example","title":"Complete Real-World Example","text":"Python<pre><code>from fletx.core import FletXService, FletXController, FletXPage, HTTPClient\nfrom fletx.decorators import obx\nimport flet as ft\n\n# Service Layer\nclass PostAPIService(FletXService):\n    def __init__(self):\n        super().__init__(\n            name=\"PostAPIService\",\n            http_client=HTTPClient(\"https://jsonplaceholder.typicode.com\")\n        )\n\n    def on_start(self):\n        print(\"Post API Service started\")\n        self.set_data(\"posts_cache\", [])\n\n    def fetch_posts(self):\n        \"\"\"Fetch all posts\"\"\"\n        try:\n            response = self.http_client.get(\"/posts\")\n            posts = response.json()\n            self.set_data(\"posts_cache\", posts)\n            return posts\n        except Exception as e:\n            self.set_error(e)\n            return []\n\n    def fetch_post_details(self, post_id):\n        \"\"\"Fetch single post with comments\"\"\"\n        try:\n            post = self.http_client.get(f\"/posts/{post_id}\").json()\n            comments = self.http_client.get(f\"/posts/{post_id}/comments\").json()\n            return {\"post\": post, \"comments\": comments}\n        except Exception as e:\n            self.set_error(e)\n            return None\n\n    def create_post(self, title, body, user_id):\n        \"\"\"Create a new post\"\"\"\n        try:\n            response = self.http_client.post(\n                \"/posts\",\n                json={\"title\": title, \"body\": body, \"userId\": user_id}\n            )\n            return response.json()\n        except Exception as e:\n            self.set_error(e)\n            return None\n\n# Controller Layer\nclass PostController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.posts = self.create_rx_list([])\n        self.selected_post = self.create_rx_dict({})\n        self.post_service = PostAPIService()\n\n        # Computed\n        self.post_count = self.create_computed(\n            lambda: len(self.posts)\n        )\n\n    def on_ready(self):\n        # Load posts when controller is ready\n        self.load_posts()\n\n    def load_posts(self):\n        self.set_loading(True)\n        try:\n            posts = self.post_service.fetch_posts()\n            self.posts.value = posts\n            self.emit_local(\"posts_loaded\", len(posts))\n        finally:\n            self.set_loading(False)\n\n    def select_post(self, post_id):\n        details = self.post_service.fetch_post_details(post_id)\n        if details:\n            self.selected_post.value = details\n\n    def create_post(self, title, body):\n        result = self.post_service.create_post(title, body, 1)\n        if result:\n            self.posts.append(result)\n            self.emit_local(\"post_created\", result)\n\n# View Layer\nclass PostPage(FletXPage):\n    def __init__(self):\n        super().__init__(padding=20)\n        self.controller = PostController()\n        self.title_input = ft.TextField(label=\"Title\")\n        self.body_input = ft.TextField(label=\"Body\", multiline=True, min_lines=3)\n\n    def on_init(self):\n        self.controller.on_local(\"posts_loaded\", self._on_posts_loaded)\n\n    def _on_posts_loaded(self, event):\n        print(f\"Loaded {event.data} posts\")\n\n    def _create_post(self):\n        title = self.title_input.value\n        body = self.body_input.value\n        if title and body:\n            self.controller.create_post(title, body)\n            self.title_input.value = \"\"\n            self.body_input.value = \"\"\n            self.refresh()\n\n    @obx\n    def build(self):\n        # Loading state\n        if self.controller.is_loading:\n            return ft.Center(content=ft.ProgressRing())\n\n        # Error state\n        if self.controller.error_message:\n            return ft.Center(\n                content=ft.Column([\n                    ft.Icon(ft.icons.ERROR, color=ft.colors.RED),\n                    ft.Text(f\"Error: {self.controller.error_message}\"),\n                    ft.ElevatedButton(\"Retry\", on_click=lambda _: self.controller.load_posts())\n                ])\n            )\n\n        # Posts list\n        return ft.Column([\n            # Header\n            ft.Text(\n                f\"Posts ({self.controller.post_count})\",\n                size=24,\n                weight=\"bold\"\n            ),\n\n            # Create post form\n            ft.Card(\n                content=ft.Container(\n                    content=ft.Column([\n                        self.title_input,\n                        self.body_input,\n                        ft.ElevatedButton(\n                            \"Create Post\",\n                            on_click=lambda _: self._create_post()\n                        )\n                    ], spacing=10),\n                    padding=15\n                )\n            ),\n\n            # Posts list\n            ft.ListView([\n                ft.Card(\n                    content=ft.Container(\n                        content=ft.Column([\n                            ft.Text(post[\"title\"], weight=\"bold\", size=14),\n                            ft.Text(post[\"body\"][:100] + \"...\", size=12, color=ft.colors.GREY),\n                            ft.Row([\n                                ft.TextButton(\n                                    \"View Details\",\n                                    on_click=lambda _, pid=post[\"id\"]: self.controller.select_post(pid)\n                                )\n                            ])\n                        ], spacing=5),\n                        padding=10\n                    )\n                )\n                for post in self.controller.posts\n            ])\n        ], scroll=ft.ScrollMode.AUTO, spacing=15)\n</code></pre>"},{"location":"getting-started/services/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/services/#1-keep-services-focused","title":"1. Keep Services Focused","text":"Python<pre><code># \u2705 Good - service handles one concern\nclass UserAPIService(FletXService):\n    def fetch_users(self):\n        pass\n\n    def fetch_user(self, user_id):\n        pass\n\n# \u274c Avoid - service doing too much\nclass AppService(FletXService):\n    def fetch_users(self):\n        pass\n\n    def fetch_posts(self):\n        pass\n\n    def fetch_comments(self):\n        pass\n\n    def send_email(self):\n        pass\n</code></pre>"},{"location":"getting-started/services/#2-use-dependency-injection","title":"2. Use Dependency Injection","text":"Python<pre><code># \u2705 Good - inject service dependencies\nclass UserController(FletXController):\n    def __init__(self, user_service):\n        super().__init__()\n        self.user_service = user_service\n\n# \u274c Avoid - create service directly\nclass UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.user_service = UserAPIService()  # Hard to test\n</code></pre>"},{"location":"getting-started/services/#3-handle-errors-properly","title":"3. Handle Errors Properly","text":"Python<pre><code># \u2705 Good - error handling\ndef fetch_data(self):\n    try:\n        response = self.http_client.get(\"/data\")\n        return response.json()\n    except Exception as e:\n        self.set_error(e)\n        return None\n\n# \u274c Avoid - ignoring errors\ndef fetch_data(self):\n    response = self.http_client.get(\"/data\")\n    return response.json()  # Crashes on error\n</code></pre>"},{"location":"getting-started/services/#4-clean-up-resources","title":"4. Clean Up Resources","text":"Python<pre><code># \u2705 Good - cleanup in on_stop\ndef on_start(self):\n    self.websocket = WebSocket()\n    self.websocket.connect()\n\ndef on_stop(self):\n    if self.websocket:\n        self.websocket.close()\n\n# \u274c Avoid - leaving resources open\ndef on_start(self):\n    self.websocket = WebSocket()\n    self.websocket.connect()\n    # No cleanup!\n</code></pre>"},{"location":"getting-started/services/#5-setup-data-in-on_start","title":"5. Setup Data in on_start","text":"Python<pre><code># \u2705 Good - initialize data\ndef on_start(self):\n    self.set_data(\"cache\", {})\n    self.set_data(\"config\", {\"timeout\": 30})\n\n# \u274c Avoid - uninitialized data\ndef fetch_from_cache(self, key):\n    cache = self.get_data(\"cache\", {})  # May not exist yet\n</code></pre>"},{"location":"getting-started/services/#summary","title":"Summary","text":"Feature Purpose <code>FletXService</code> Base class for services <code>HTTPClient</code> Built-in HTTP client <code>on_start()</code> Initialize service <code>on_start_async()</code> Async initialization <code>on_ready()</code> Called when ready <code>on_stop()</code> Cleanup on stop <code>on_stop_async()</code> Async cleanup <code>on_dispose()</code> Final cleanup <code>on_state_changed()</code> State change hook <code>state</code> Current service state <code>is_ready</code> Check if ready <code>is_loading</code> Check if loading <code>has_error</code> Check for errors <code>error</code> Get error <code>set_error()</code> Set error <code>set_data()</code> Store service data <code>get_data()</code> Retrieve service data <code>clear_data()</code> Clear all data <code>start()</code> Start service <code>stop()</code> Stop service <code>restart()</code> Restart service <code>dispose()</code> Dispose service <code>http_client</code> Access HTTP client <code>IDLE</code> Idle state <code>LOADING</code> Loading state <code>READY</code> Ready state <code>ERROR</code> Error state <code>DISPOSED</code> Disposed state"},{"location":"getting-started/services/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Controllers that use services</li> <li>Explore Dependency Injection to share services</li> <li>Check Architecture for service patterns</li> <li>Read about State Management for service data</li> </ul>"},{"location":"getting-started/state-management/","title":"State Management","text":"<p>TL;DR: FletX provides reactive variables (<code>RxInt</code>, <code>RxStr</code>, <code>RxBool</code>, <code>RxList</code>, <code>RxDict</code>) that automatically notify observers when they change. Watch them with <code>.listen()</code>, compute derived values with <code>create_computed()</code>, and use <code>@obx</code> decorator to rebuild UI components automatically. No manual <code>update()</code> calls needed.</p>"},{"location":"getting-started/state-management/#what-is-state-management","title":"What is State Management?","text":"<p>State is the data your app depends on at any moment - a user's profile, the list of todos, whether a modal is open, API loading status, etc.</p> <p>State Management means organizing, storing, and updating that data in a way that:</p> <ul> <li>Keeps it consistent and predictable</li> <li>Makes it easy to update</li> <li>Automatically syncs related UI and logic</li> <li>Prevents bugs from scattered, manual updates</li> </ul> <p>FletX makes state management reactive - when state changes, everything depending on it automatically updates.</p>"},{"location":"getting-started/state-management/#why-reactive-state","title":"Why Reactive State?","text":"<p>Manual State - Scattered Updates:</p> Python<pre><code>class TodoPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.todos = []  # Plain Python list\n\n    def add_todo(self, title):\n        self.todos.append({\"title\": title, \"done\": False})\n        # Manual update needed everywhere\n        self._refresh_todo_list()\n        self._update_count()\n        self._save_to_db()\n        self.page_instance.update()\n\n    def _refresh_todo_list(self):\n        # Manually rebuild UI\n        pass\n\n    def _update_count(self):\n        # Manually update count\n        pass\n\n    def _save_to_db(self):\n        # Manually persist\n        pass\n\n    def build(self):\n        # State is mixed with UI\n        return ft.Column([\n            ft.Text(f\"Todos: {len(self.todos)}\"),\n            ft.Column([ft.Text(t[\"title\"]) for t in self.todos])\n        ])\n</code></pre> <p>Problems:</p> <ul> <li>State updates scattered everywhere</li> <li>Easy to miss an update</li> <li>Manual refresh calls</li> <li>Bugs from inconsistent state</li> </ul> <p>Reactive State - Automatic Sync:</p> Python<pre><code>class TodoController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.todos = self.create_rx_list([])\n\n        # Computed: auto-updates when todos change\n        self.count = self.create_computed(lambda: len(self.todos))\n\n    def add_todo(self, title):\n        self.todos.append({\"title\": title, \"done\": False})\n        # Everything updates automatically!\n\nclass TodoPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = TodoController()\n\n    @obx\n    def build(self):\n        # UI rebuilds automatically when todos changes\n        return ft.Column([\n            ft.Text(f\"Todos: {self.controller.count}\"),  # Auto-updates\n            ft.Column([ft.Text(t[\"title\"]) for t in self.controller.todos])\n        ])\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Single source of truth</li> <li>\u2705 Automatic UI updates</li> <li>\u2705 No manual refresh calls</li> <li>\u2705 Fewer bugs</li> <li>\u2705 Easy to test</li> </ul>"},{"location":"getting-started/state-management/#your-first-reactive-variable","title":"Your First Reactive Variable","text":""},{"location":"getting-started/state-management/#step-1-create-a-reactive-variable","title":"Step 1: Create a Reactive Variable","text":"Python<pre><code>from fletx.core import FletXController\n\nclass CounterController(FletXController):\n    def __init__(self):\n        super().__init__()\n        # Create a reactive integer\n        self.count = self.create_rx_int(0)\n</code></pre>"},{"location":"getting-started/state-management/#step-2-use-and-update-it","title":"Step 2: Use and Update It","text":"Python<pre><code># Get the value\ncurrent_count = self.count.value\n\n# Set a new value\nself.count.value = 5\n# Or self.count.set(5)\n\n# Use type-specific methods\nself.count.increment()  # count += 1\nself.count.decrement()  # count -= 1\n</code></pre>"},{"location":"getting-started/state-management/#step-3-watch-for-changes","title":"Step 3: Watch for Changes","text":"Python<pre><code>def on_ready(self):\n    # Call function when count changes\n    self.count.listen(self._on_count_change)\n\ndef _on_count_change(self):\n    print(f\"Count is now: {self.count.value}\")\n</code></pre>"},{"location":"getting-started/state-management/#step-4-use-in-ui-with-obx","title":"Step 4: Use in UI with <code>@obx</code>","text":"Python<pre><code>class CounterPage(FletXPage):\n    @obx\n    def build(self):\n        return ft.Column([\n            ft.Text(self.controller.count),  # Auto-updates\n            ft.ElevatedButton(\"+\", on_click=lambda _: self.controller.count.increment())\n        ])\n</code></pre> <p>Done! \ud83c\udf89</p>"},{"location":"getting-started/state-management/#reactive-types","title":"Reactive Types","text":""},{"location":"getting-started/state-management/#rxint-reactive-integer","title":"RxInt - Reactive Integer","text":"Python<pre><code>class MyController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.age = self.create_rx_int(30)\n\n    def have_birthday(self):\n        self.age.increment()\n\n    def set_age(self, new_age):\n        self.age.value = new_age\n</code></pre> <p>Methods:</p> <ul> <li><code>increment(step=1)</code> - Add to value</li> <li><code>decrement(step=1)</code> - Subtract from value</li> <li><code>value</code> - Get/set the current value</li> <li><code>set(new_value)</code> - Set a new value</li> <li><code>listen(callback)</code> - Watch for changes</li> </ul>"},{"location":"getting-started/state-management/#rxstr-reactive-string","title":"RxStr - Reactive String","text":"Python<pre><code>class UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.username = self.create_rx_str(\"\")\n        self.email = self.create_rx_str(\"\")\n\n    def update_username(self, new_username):\n        self.username.value = new_username\n</code></pre> <p>Methods:</p> <ul> <li><code>append(text)</code> - Add text to the string</li> <li><code>clear()</code> - Empty the string</li> <li><code>value</code> - Get/set the current value</li> <li><code>listen(callback)</code> - Watch for changes</li> </ul>"},{"location":"getting-started/state-management/#rxbool-reactive-boolean","title":"RxBool - Reactive Boolean","text":"Python<pre><code>class ThemeController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.is_dark_mode = self.create_rx_bool(False)\n\n    def toggle_theme(self):\n        self.is_dark_mode.toggle()\n</code></pre> <p>Methods:</p> <ul> <li><code>toggle()</code> - Flip between true/false</li> <li><code>value</code> - Get/set the current value</li> <li><code>listen(callback)</code> - Watch for changes</li> </ul>"},{"location":"getting-started/state-management/#rxlist-reactive-list","title":"RxList - Reactive List","text":"Python<pre><code>class ShoppingController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.items = self.create_rx_list([])\n\n    def add_item(self, item):\n        self.items.append(item)\n\n    def remove_item(self, item):\n        self.items.remove(item)\n\n    def clear_cart(self):\n        self.items.clear()\n\n    def get_item(self, index):\n        return self.items[index]\n</code></pre> <p>Methods:</p> <ul> <li><code>append(item)</code> - Add item</li> <li><code>remove(item)</code> - Remove item</li> <li><code>clear()</code> - Remove all items</li> <li><code>pop(index=-1)</code> - Remove and return item</li> <li><code>extend(list)</code> - Add multiple items</li> <li><code>__len__()</code> - Get length</li> <li><code>__getitem__(index)</code> - Access by index</li> <li><code>__setitem__(index, value)</code> - Update by index</li> <li><code>listen(callback)</code> - Watch for changes</li> </ul>"},{"location":"getting-started/state-management/#rxdict-reactive-dictionary","title":"RxDict - Reactive Dictionary","text":"Python<pre><code>class ConfigController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.settings = self.create_rx_dict({\n            \"theme\": \"light\",\n            \"language\": \"en\"\n        })\n\n    def update_theme(self, theme):\n        self.settings[\"theme\"] = theme\n\n    def get_language(self):\n        return self.settings.get(\"language\", \"en\")\n</code></pre> <p>Methods:</p> <ul> <li><code>__setitem__(key, value)</code> - Set value</li> <li><code>__getitem__(key)</code> - Get value</li> <li><code>__delitem__(key)</code> - Delete key</li> <li><code>get(key, default)</code> - Get with default</li> <li><code>update(dict)</code> - Merge with dict</li> <li><code>clear()</code> - Remove all items</li> <li><code>listen(callback)</code> - Watch for changes</li> </ul>"},{"location":"getting-started/state-management/#reactivet-generic-reactive","title":"Reactive[T] - Generic Reactive","text":"Python<pre><code>from fletx.core import Reactive\n\nclass UserModel:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass UserController(FletXController):\n    def __init__(self):\n        super().__init__()\n        # Generic reactive for any object\n        self.user = self.create_reactive(UserModel(\"John\", \"john@example.com\"))\n\n    def update_user(self, user):\n        self.user.value = user\n</code></pre>"},{"location":"getting-started/state-management/#listening-to-changes","title":"Listening to Changes","text":""},{"location":"getting-started/state-management/#basic-listener","title":"Basic Listener","text":"Python<pre><code>class DataController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.data = self.create_rx_str(\"\")\n\n    def on_ready(self):\n        # Call function whenever data changes\n        self.data.listen(self._on_data_change)\n\n    def _on_data_change(self):\n        print(f\"Data changed: {self.data.value}\")\n</code></pre>"},{"location":"getting-started/state-management/#stopping-listeners","title":"Stopping Listeners","text":"Python<pre><code>def on_ready(self):\n    # listen() returns an Observer\n    observer = self.data.listen(self._on_data_change)\n\n    # Later, dispose to stop listening\n    observer.dispose()\n</code></pre>"},{"location":"getting-started/state-management/#multiple-listeners","title":"Multiple Listeners","text":"Python<pre><code>def on_ready(self):\n    self.count.listen(self._log_count)\n    self.count.listen(self._update_ui)\n    self.count.listen(self._save_to_db)\n\n    # All three are called when count changes\n</code></pre>"},{"location":"getting-started/state-management/#computed-properties","title":"Computed Properties","text":"<p>Computed properties are derived values that automatically update when their dependencies change:</p> Python<pre><code>class PriceController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.price = self.create_rx_int(100)\n        self.quantity = self.create_rx_int(2)\n        self.tax_rate = self.create_rx_int(10)\n\n        # Computed: subtotal = price * quantity\n        self.subtotal = self.create_computed(\n            lambda: self.price.value * self.quantity.value\n        )\n\n        # Computed: tax = subtotal * tax_rate / 100\n        self.tax = self.create_computed(\n            lambda: self.subtotal.value * self.tax_rate.value / 100\n        )\n\n        # Computed: total = subtotal + tax\n        self.total = self.create_computed(\n            lambda: self.subtotal.value + self.tax.value\n        )\n\n    def on_ready(self):\n        # Listen to computed values\n        self.total.listen(self._on_total_change)\n\n    def _on_total_change(self):\n        print(f\"Total: {self.total.value}\")\n</code></pre> <p>How it works:</p> <ol> <li>Computed automatically detects dependencies (price, quantity, tax_rate)</li> <li>When any dependency changes, computed is recalculated</li> <li>Listeners are notified of the new value</li> <li>UI components with <code>@obx</code> automatically rebuild</li> </ol> <p>Benefits:</p> <ul> <li>No manual recalculation</li> <li>No stale values</li> <li>Efficient - only recalculates when needed</li> <li>Composable - computed can depend on other computed values</li> </ul>"},{"location":"getting-started/state-management/#observers-and-cleanup","title":"Observers and Cleanup","text":"<p>Each listener is an Observer with a lifecycle:</p> Python<pre><code>class WebsocketController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.connected = self.create_rx_bool(False)\n        self.observer = None\n\n    def on_ready(self):\n        # Create observer\n        self.observer = self.connected.listen(self._on_connected_change)\n\n    def _on_connected_change(self):\n        if self.connected.value:\n            self._connect_websocket()\n        else:\n            self._disconnect_websocket()\n\n    def _connect_websocket(self):\n        print(\"Connecting...\")\n\n    def _disconnect_websocket(self):\n        print(\"Disconnecting...\")\n\n    def on_disposed(self):\n        # Cleanup: stop listening\n        if self.observer:\n            self.observer.dispose()\n</code></pre>"},{"location":"getting-started/state-management/#reactivity-in-ui","title":"Reactivity in UI","text":""},{"location":"getting-started/state-management/#using-obx-decorator","title":"Using <code>@obx</code> Decorator","text":"<p>The <code>@obx</code> decorator makes a method reactive - it rebuilds automatically when its reactive dependencies change:</p> Python<pre><code>from fletx.decorators import obx\n\nclass TodoPage(FletXPage):\n    def __init__(self):\n        super().__init__()\n        self.controller = TodoController()\n\n    @obx\n    def todo_item_widget(self, todo):\n        \"\"\"This rebuilds when reactive values in the controller change\"\"\"\n        return ft.Card(\n            content=ft.Container(\n                content=ft.Text(todo[\"title\"]),\n                padding=10\n            )\n        )\n\n    @obx\n    def build(self):\n        \"\"\"Main UI rebuilds automatically when todos or count changes\"\"\"\n        return ft.Column([\n            ft.Text(\n                f\"Count: {self.controller.count}\",  # Auto-updates\n                size=24,\n                weight=\"bold\"\n            ),\n            ft.ListView([\n                self.todo_item_widget(todo)\n                for todo in self.controller.todos  # Auto-updates\n            ])\n        ])\n</code></pre> <p>How it works:</p> <ol> <li><code>@obx</code> wraps the method</li> <li>When the method runs, it tracks reactive variables used</li> <li>If any reactive variable changes, the method is called again</li> <li>UI is automatically rebuilt with new values</li> </ol>"},{"location":"getting-started/state-management/#without-obx-manual-updates","title":"Without <code>@obx</code> - Manual Updates","text":"Python<pre><code># \u274c Without @obx - need manual updates\ndef build(self):\n    def on_count_change():\n        count_text.value = str(self.controller.count.value)\n        self.page_instance.update()\n\n    self.controller.count.listen(on_count_change)\n\n    count_text = ft.Text(str(self.controller.count.value))\n    return count_text\n\n# \u2705 With @obx - automatic!\n@obx\ndef build(self):\n    return ft.Text(str(self.controller.count.value))\n</code></pre>"},{"location":"getting-started/state-management/#complete-real-world-example","title":"Complete Real-World Example","text":"Python<pre><code># controller.py\n\nfrom fletx.core import FletXController\n\nclass ShoppingController(FletXController):\n    def __init__(self):\n        super().__init__()\n        self.items = self.create_rx_list([])\n        self.tax_rate = self.create_rx_int(10)\n\n        # Computed subtotal\n        self.subtotal = self.create_computed(\n            lambda: sum([item[\"price\"] * item[\"quantity\"] \n                        for item in self.items.value])\n        )\n\n        # Computed tax\n        self.tax = self.create_computed(\n            lambda: self.subtotal.value * self.tax_rate.value / 100\n        )\n\n        # Computed total\n        self.total = self.create_computed(\n            lambda: self.subtotal.value + self.tax.value\n        )\n\n        # Computed item count\n        self.item_count = self.create_computed(\n            lambda: sum([item[\"quantity\"] for item in self.items.value])\n        )\n\n    def add_item(self, name, price):\n        self.items.append({\n            \"id\": len(self.items) + 1,\n            \"name\": name,\n            \"price\": price,\n            \"quantity\": 1\n        })\n        self.emit_local(\"item_added\", name)\n\n    def update_quantity(self, item_id, quantity):\n        for item in self.items.value:\n            if item[\"id\"] == item_id:\n                item[\"quantity\"] = quantity\n                # Trigger update\n                self.items.value = list(self.items.value)\n                break\n\n    def remove_item(self, item_id):\n        self.items.value = [item for item in self.items if item[\"id\"] != item_id]\n\n    def clear_cart(self):\n        self.items.clear()\n</code></pre> Python<pre><code># Page.py\n\nfrom fletx.core import FletXPage\nfrom fletx.decorators import obx\nimport flet as ft\n\nclass ShoppingPage(FletXPage):\n    def __init__(self):\n        super().__init__(padding=20)\n        self.controller = ShoppingController()\n\n    def on_init(self):\n        self.controller.on_local(\"item_added\", self._on_item_added)\n\n    def _on_item_added(self, event):\n        print(f\"Added: {event.data}\")\n\n    @obx\n    def price_summary(self):\n        \"\"\"Price summary that rebuilds when totals change\"\"\"\n        return ft.Card(\n            content=ft.Container(\n                content=ft.Column([\n                    ft.Row([\n                        ft.Text(\"Subtotal:\"),\n                        ft.Text(f\"${self.controller.subtotal.value:.2f}\", weight=\"bold\")\n                    ]),\n                    ft.Row([\n                        ft.Text(\"Tax (10%):\"),\n                        ft.Text(f\"${self.controller.tax.value:.2f}\", weight=\"bold\")\n                    ]),\n                    ft.Divider(),\n                    ft.Row([\n                        ft.Text(\"Total:\"),\n                        ft.Text(f\"${self.controller.total.value:.2f}\", size=18, weight=\"bold\")\n                    ])\n                ], spacing=10),\n                padding=15\n            )\n        )\n\n    @obx\n    def build(self):\n        return ft.Column([\n            # Header\n            ft.Text(\n                f\"Shopping Cart ({self.controller.item_count} items)\",\n                size=24,\n                weight=\"bold\"\n            ),\n\n            # Items list\n            ft.ListView([\n                ft.Card(\n                    content=ft.Container(\n                        content=ft.Row([\n                            ft.Column([\n                                ft.Text(item[\"name\"], weight=\"bold\"),\n                                ft.Text(f\"${item['price']}\", size=12, color=ft.colors.GREY)\n                            ], expand=True),\n                            ft.Row([\n                                ft.IconButton(\n                                    ft.icons.REMOVE,\n                                    on_click=lambda _, id=item[\"id\"]: \n                                        self.controller.update_quantity(id, max(1, item[\"quantity\"]-1))\n                                ),\n                                ft.Text(str(item[\"quantity\"])),\n                                ft.IconButton(\n                                    ft.icons.ADD,\n                                    on_click=lambda _, id=item[\"id\"]: \n                                        self.controller.update_quantity(id, item[\"quantity\"]+1)\n                                ),\n                                ft.IconButton(\n                                    ft.icons.DELETE,\n                                    on_click=lambda _, id=item[\"id\"]: \n                                        self.controller.remove_item(id)\n                                )\n                            ])\n                        ]),\n                        padding=10\n                    )\n                )\n                for item in self.controller.items\n            ], spacing=5),\n\n            # Price summary\n            self.price_summary(),\n\n            # Action buttons\n            ft.Row([\n                ft.ElevatedButton(\n                    \"Add Item\",\n                    on_click=lambda _: self.controller.add_item(\"Product\", 99.99)\n                ),\n                ft.OutlinedButton(\n                    \"Clear Cart\",\n                    on_click=lambda _: self.controller.clear_cart()\n                )\n            ], spacing=10)\n        ], scroll=ft.ScrollMode.AUTO)\n</code></pre>"},{"location":"getting-started/state-management/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/state-management/#1-use-type-specific-creators","title":"1. Use Type-Specific Creators","text":"Python<pre><code># \u2705 Good - use create_rx_* methods\nself.count = self.create_rx_int(0)\nself.name = self.create_rx_str(\"\")\nself.items = self.create_rx_list([])\n\n# \u274c Avoid - importing types directly\nfrom fletx.core.state import RxInt\nself.count = RxInt(0)  # Not tracked by controller lifecycle\n</code></pre>"},{"location":"getting-started/state-management/#2-use-obx-for-reactive-methods","title":"2. Use <code>@obx</code> for Reactive Methods","text":"Python<pre><code># \u2705 Good - method rebuilds when dependencies change\n@obx\ndef user_card(self):\n    return ft.Card(content=ft.Text(self.controller.username.value))\n\n# \u274c Avoid - regular method won't react\ndef user_card(self):\n    return ft.Card(content=ft.Text(self.controller.username.value))\n</code></pre>"},{"location":"getting-started/state-management/#3-use-computed-for-derived-values","title":"3. Use Computed for Derived Values","text":"Python<pre><code># \u2705 Good - computed auto-updates\nself.full_name = self.create_computed(\n    lambda: f\"{self.first.value} {self.last.value}\"\n)\n\n# \u274c Avoid - manual updates\nself.full_name = self.create_rx_str(\"\")\nself.first.listen(lambda: self.full_name.value = f\"{self.first.value} {self.last.value}\")\n</code></pre>"},{"location":"getting-started/state-management/#4-listen-at-right-time","title":"4. Listen at Right Time","text":"Python<pre><code># \u2705 Good - setup listeners in on_ready\ndef on_ready(self):\n    self.count.listen(self._on_count_change)\n\n# \u274c Avoid - setup in __init__\ndef __init__(self):\n    self.count.listen(self._on_count_change)  # Might not work\n</code></pre>"},{"location":"getting-started/state-management/#5-clean-up-listeners","title":"5. Clean Up Listeners","text":"Python<pre><code># \u2705 Good - dispose observers\ndef on_ready(self):\n    self.observer = self.data.listen(self._on_data)\n\ndef on_disposed(self):\n    if self.observer:\n        self.observer.dispose()\n\n# \u274c Avoid - leave listeners hanging\ndef on_ready(self):\n    self.data.listen(self._on_data)  # Memory leak potential\n</code></pre>"},{"location":"getting-started/state-management/#6-keep-ui-methods-pure","title":"6. Keep UI Methods Pure","text":"Python<pre><code># \u2705 Good - no side effects in @obx methods\n@obx\ndef build(self):\n    return ft.Text(self.controller.value)\n\n# \u274c Avoid - side effects in @obx\n@obx\ndef build(self):\n    save_to_db(self.controller.value)  # Don't do this!\n    return ft.Text(self.controller.value)\n</code></pre>"},{"location":"getting-started/state-management/#summary","title":"Summary","text":"Concept Purpose RxInt Reactive integer with increment/decrement RxStr Reactive string with append/clear RxBool Reactive boolean with toggle RxList Reactive list with append/remove/pop RxDict Reactive dictionary with get/update Reactive[T] Generic reactive value Computed Derived value that auto-updates Observer Listens to changes, can be disposed @obx Decorator that rebuilds on changes .listen() Watch for changes .value Get/set current value create_computed() Create computed property create_rx_int() Create reactive int create_rx_str() Create reactive string create_rx_bool() Create reactive boolean create_rx_list() Create reactive list create_rx_dict() Create reactive dictionary"},{"location":"getting-started/state-management/#next-steps","title":"Next Steps","text":"<ul> <li>Learn how to use state in Controllers</li> <li>Explore Pages with reactive UI</li> <li>Understand Dependency Injection for sharing state</li> <li>Check Decorators for advanced reactivity with <code>@obx</code></li> <li>Read about Routing to manage state across pages</li> </ul>"}]}